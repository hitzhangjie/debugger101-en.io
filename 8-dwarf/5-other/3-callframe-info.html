
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>8.5.3 Call Frame Information · GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="../../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-md-toc/style.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="4-macro-info.html" />
    
    
    <link rel="prev" href="2-lineno-table.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../../">
            
                <a href="../../">
            
                    
                    1 Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../../2-preface/">
            
                <a href="../../2-preface/">
            
                    
                    2 Preface
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="../../3-terms/">
            
                <a href="../../3-terms/">
            
                    
                    3 Common Terms
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="../../4-basics/">
            
                <a href="../../4-basics/">
            
                    
                    4 Software Debugging Basics
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="../../4-basics/1-purposes.html">
            
                <a href="../../4-basics/1-purposes.html">
            
                    
                    4.1 Debugging Purposes
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2" data-path="../../4-basics/2-dependencies.html">
            
                <a href="../../4-basics/2-dependencies.html">
            
                    
                    4.2 Debugging Dependencies
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3" data-path="../../4-basics/3-countertactics.html">
            
                <a href="../../4-basics/3-countertactics.html">
            
                    
                    4.3 Anti-Debugging Techniques
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="../../5-debugger-skeleton/">
            
                <a href="../../5-debugger-skeleton/">
            
                    
                    5 Entering Debugger Development
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.1" data-path="../../5-debugger-skeleton/1-debugger_skeleton.html">
            
                <a href="../../5-debugger-skeleton/1-debugger_skeleton.html">
            
                    
                    5.1 Debugger Overview
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.2" data-path="../../5-debugger-skeleton/2-debugger_demo.html">
            
                <a href="../../5-debugger-skeleton/2-debugger_demo.html">
            
                    
                    5.2 Debugger Example
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="../../6-develop-inst-debugger/">
            
                <a href="../../6-develop-inst-debugger/">
            
                    
                    6 Developing Go Instruction-Level Debugger
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.6.1" data-path="../../6-develop-inst-debugger/1-process_start.html">
            
                <a href="../../6-develop-inst-debugger/1-process_start.html">
            
                    
                    6.1 Process Launch
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2" data-path="../../6-develop-inst-debugger/2-process_attach.html">
            
                <a href="../../6-develop-inst-debugger/2-process_attach.html">
            
                    
                    6.2 Process Attach
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.3" data-path="../../6-develop-inst-debugger/3-process_start_attach.html">
            
                <a href="../../6-develop-inst-debugger/3-process_start_attach.html">
            
                    
                    6.3 Launch & Attach
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.4" data-path="../../6-develop-inst-debugger/4-debug-session.html">
            
                <a href="../../6-develop-inst-debugger/4-debug-session.html">
            
                    
                    6.4 Debug Session
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.5" data-path="../../6-develop-inst-debugger/5-disassemble.html">
            
                <a href="../../6-develop-inst-debugger/5-disassemble.html">
            
                    
                    6.5 Disassembly
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.6" data-path="../../6-develop-inst-debugger/6-breakpoint.html">
            
                <a href="../../6-develop-inst-debugger/6-breakpoint.html">
            
                    
                    6.6 Adding Breakpoints
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.7" data-path="../../6-develop-inst-debugger/7-breakpoints.html">
            
                <a href="../../6-develop-inst-debugger/7-breakpoints.html">
            
                    
                    6.7 Listing Breakpoints
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.8" data-path="../../6-develop-inst-debugger/8-clear.html">
            
                <a href="../../6-develop-inst-debugger/8-clear.html">
            
                    
                    6.8 Removing Breakpoints
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.9" data-path="../../6-develop-inst-debugger/9-clearall.html">
            
                <a href="../../6-develop-inst-debugger/9-clearall.html">
            
                    
                    6.9 Clearing All Breakpoints
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.10" data-path="../../6-develop-inst-debugger/10-step.html">
            
                <a href="../../6-develop-inst-debugger/10-step.html">
            
                    
                    6.10 Stepping Operations
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.11" data-path="../../6-develop-inst-debugger/11-continue.html">
            
                <a href="../../6-develop-inst-debugger/11-continue.html">
            
                    
                    6.11 Running to Breakpoint
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.12" data-path="../../6-develop-inst-debugger/12-pmem.html">
            
                <a href="../../6-develop-inst-debugger/12-pmem.html">
            
                    
                    6.12 Printing Memory Data
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.13" data-path="../../6-develop-inst-debugger/13-pregs.html">
            
                <a href="../../6-develop-inst-debugger/13-pregs.html">
            
                    
                    6.13 Printing Register Data
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.14" data-path="../../6-develop-inst-debugger/14-set-mem.html">
            
                <a href="../../6-develop-inst-debugger/14-set-mem.html">
            
                    
                    6.14 Modifying Memory Data
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.15" data-path="../../6-develop-inst-debugger/15-set-regs.html">
            
                <a href="../../6-develop-inst-debugger/15-set-regs.html">
            
                    
                    6.15 Modifying Register Data
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.16" data-path="../../6-develop-inst-debugger/20-trace_new_threads.html">
            
                <a href="../../6-develop-inst-debugger/20-trace_new_threads.html">
            
                    
                    6.20 Tracing Multi-threaded Programs 1
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.17" data-path="../../6-develop-inst-debugger/21-trace_old_threads.html">
            
                <a href="../../6-develop-inst-debugger/21-trace_old_threads.html">
            
                    
                    6.21 Tracing Multi-threaded Programs 2
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.18" data-path="../../6-develop-inst-debugger/80-aslr.html">
            
                <a href="../../6-develop-inst-debugger/80-aslr.html">
            
                    
                    6.80 Understanding ASLR
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.19" data-path="../../6-develop-inst-debugger/99-more.html">
            
                <a href="../../6-develop-inst-debugger/99-more.html">
            
                    
                    6.99 More...
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="../../7-headto-sym-debugger/">
            
                <a href="../../7-headto-sym-debugger/">
            
                    
                    7 Advancing to Symbol-Level Debugger
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.1" data-path="../../7-headto-sym-debugger/1-how-go-build-works.html">
            
                <a href="../../7-headto-sym-debugger/1-how-go-build-works.html">
            
                    
                    7.1 Go Build Internals
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.2" data-path="../../7-headto-sym-debugger/2-elf.html">
            
                <a href="../../7-headto-sym-debugger/2-elf.html">
            
                    
                    7.2 Understanding ELF Files
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.3" data-path="../../7-headto-sym-debugger/3-syms.html">
            
                <a href="../../7-headto-sym-debugger/3-syms.html">
            
                    
                    7.3 Symbols & Symbol Tables
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.4" data-path="../../7-headto-sym-debugger/4-syms-resolve-reloc.html">
            
                <a href="../../7-headto-sym-debugger/4-syms-resolve-reloc.html">
            
                    
                    7.4 Symbol Resolution & Relocation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.5" data-path="../../7-headto-sym-debugger/5-loading.html">
            
                <a href="../../7-headto-sym-debugger/5-loading.html">
            
                    
                    7.5 Loading
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.6" data-path="../../7-headto-sym-debugger/6-gopkg-debug/">
            
                <a href="../../7-headto-sym-debugger/6-gopkg-debug/">
            
                    
                    7.6 Go Standard Library debug/*
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.6.1" data-path="../../7-headto-sym-debugger/6-gopkg-debug/1-elf.html">
            
                <a href="../../7-headto-sym-debugger/6-gopkg-debug/1-elf.html">
            
                    
                    7.6.1 debug/elf
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.6.2" data-path="../../7-headto-sym-debugger/6-gopkg-debug/2-gosym.html">
            
                <a href="../../7-headto-sym-debugger/6-gopkg-debug/2-gosym.html">
            
                    
                    7.6.2 debug/gosym
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.6.3" data-path="../../7-headto-sym-debugger/6-gopkg-debug/3-dwarf.html">
            
                <a href="../../7-headto-sym-debugger/6-gopkg-debug/3-dwarf.html">
            
                    
                    7.6.3 debug/dwarf
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.7.7" data-path="../../7-headto-sym-debugger/7-headto-dwarf/">
            
                <a href="../../7-headto-sym-debugger/7-headto-dwarf/">
            
                    
                    7.7 Advancing to DWARF
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.7.1" data-path="../../7-headto-sym-debugger/7-headto-dwarf/1-gopkgs-about-dwarf.html">
            
                <a href="../../7-headto-sym-debugger/7-headto-dwarf/1-gopkgs-about-dwarf.html">
            
                    
                    7.7.1 Related Go Packages
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.7.2" data-path="../../7-headto-sym-debugger/7-headto-dwarf/2-delve-into-internals.html">
            
                <a href="../../7-headto-sym-debugger/7-headto-dwarf/2-delve-into-internals.html">
            
                    
                    7.7.2 How to Crack Those Details
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.7.3" data-path="../../7-headto-sym-debugger/7-headto-dwarf/3-compiler-gen-dwarfdata.html">
            
                <a href="../../7-headto-sym-debugger/7-headto-dwarf/3-compiler-gen-dwarfdata.html">
            
                    
                    7.7.3 Compiler Generated DWARF Data
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.7.4" data-path="../../7-headto-sym-debugger/7-headto-dwarf/4-linker-gen-dwarfdata.html">
            
                <a href="../../7-headto-sym-debugger/7-headto-dwarf/4-linker-gen-dwarfdata.html">
            
                    
                    7.7.4 Linker Generated DWARF Data
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.7.5" data-path="../../7-headto-sym-debugger/7-headto-dwarf/5-headto-dwarf.html">
            
                <a href="../../7-headto-sym-debugger/7-headto-dwarf/5-headto-dwarf.html">
            
                    
                    7.7.5 Understanding DWARF
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="../">
            
                <a href="../">
            
                    
                    8 Debug Information Standard: DWARF
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.8.1" data-path="../1-history.html">
            
                <a href="../1-history.html">
            
                    
                    8.1 DWARF Development History
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.2" data-path="../2-overview.html">
            
                <a href="../2-overview.html">
            
                    
                    8.2 DWARF Content Overview
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.3" data-path="../3-dwarfdata.html">
            
                <a href="../3-dwarfdata.html">
            
                    
                    8.3 DWARF Data Classification
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.4" data-path="../4-die/">
            
                <a href="../4-die/">
            
                    
                    8.4 DIE Detailed Introduction
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.8.4.1" data-path="../4-die/1-desc-data-type.html">
            
                <a href="../4-die/1-desc-data-type.html">
            
                    
                    8.4.1 DIE Describing Data and Types
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.4.2" data-path="../4-die/2-desc-locations.html">
            
                <a href="../4-die/2-desc-locations.html">
            
                    
                    8.4.2 Location Data
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.4.3" data-path="../4-die/3-desc-code.html">
            
                <a href="../4-die/3-desc-code.html">
            
                    
                    8.4.3 DIE Describing Executable Code
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.4.4" data-path="../4-die/4-encoding.html">
            
                <a href="../4-die/4-encoding.html">
            
                    
                    8.4.4 DIE Data Encoding
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.8.5" data-path="./">
            
                <a href="./">
            
                    
                    8.5 Other Debug Data
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.8.5.1" data-path="1-accelerated-access.html">
            
                <a href="1-accelerated-access.html">
            
                    
                    8.5.1 Accelerated Access
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.5.2" data-path="2-lineno-table.html">
            
                <a href="2-lineno-table.html">
            
                    
                    8.5.2 Line Number Table Information
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.8.5.3" data-path="3-callframe-info.html">
            
                <a href="3-callframe-info.html">
            
                    
                    8.5.3 Call Frame Information
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.5.4" data-path="4-macro-info.html">
            
                <a href="4-macro-info.html">
            
                    
                    8.5.4 Macro Information
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.5.5" data-path="5-varlen-data.html">
            
                <a href="5-varlen-data.html">
            
                    
                    8.5.5 Variable Length Data
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.5.6" data-path="6-shrink-data.html">
            
                <a href="6-shrink-data.html">
            
                    
                    8.5.6 Compressed DWARF Data
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.5.7" data-path="7-elf-sections.html">
            
                <a href="7-elf-sections.html">
            
                    
                    8.5.7 ELF Sections
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.8.6" data-path="../6-practices.html">
            
                <a href="../6-practices.html">
            
                    
                    8.6 DWARF Parsing and Applications
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.7" data-path="../7-summary.html">
            
                <a href="../7-summary.html">
            
                    
                    8.7 Summary
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="../../9-develop-sym-debugger/">
            
                <a href="../../9-develop-sym-debugger/">
            
                    
                    9 Developing Go Symbol-Level Debugger
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.9.1" data-path="../../9-develop-sym-debugger/1-架构设计/">
            
                <a href="../../9-develop-sym-debugger/1-架构设计/">
            
                    
                    9.1 Architecture Design
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.9.1.1" data-path="../../9-develop-sym-debugger/1-架构设计/1-现代调试器架构.html">
            
                <a href="../../9-develop-sym-debugger/1-架构设计/1-现代调试器架构.html">
            
                    
                    9.1.1 Modern Debugger Architecture
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.1.2" data-path="../../9-develop-sym-debugger/1-架构设计/2-前端UI层设计.html">
            
                <a href="../../9-develop-sym-debugger/1-架构设计/2-前端UI层设计.html">
            
                    
                    9.1.2 Frontend UI Layer Design
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.1.3" data-path="../../9-develop-sym-debugger/1-架构设计/3-Service层设计.html">
            
                <a href="../../9-develop-sym-debugger/1-架构设计/3-Service层设计.html">
            
                    
                    9.1.3 Service Layer Design
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.1.4" data-path="../../9-develop-sym-debugger/1-架构设计/4-后端符号层设计.html">
            
                <a href="../../9-develop-sym-debugger/1-架构设计/4-后端符号层设计.html">
            
                    
                    9.1.4 Backend Symbol Layer Design
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.1.5" data-path="../../9-develop-sym-debugger/1-架构设计/5-后端目标层设计.html">
            
                <a href="../../9-develop-sym-debugger/1-架构设计/5-后端目标层设计.html">
            
                    
                    9.1.5 Backend Target Layer Design
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.1.6" data-path="../../9-develop-sym-debugger/1-架构设计/6-日志系统设计.html">
            
                <a href="../../9-develop-sym-debugger/1-架构设计/6-日志系统设计.html">
            
                    
                    9.1.6 Logging System Design
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.9.2" data-path="../../9-develop-sym-debugger/2-核心调试逻辑/">
            
                <a href="../../9-develop-sym-debugger/2-核心调试逻辑/">
            
                    
                    9.2 Core Debugging Logic
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.9.2.1" data-path="../../9-develop-sym-debugger/2-核心调试逻辑/00-cmds.html">
            
                <a href="../../9-develop-sym-debugger/2-核心调试逻辑/00-cmds.html">
            
                    
                    9.2.00 Core Debugging Commands
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2.2" data-path="../../9-develop-sym-debugger/2-核心调试逻辑/01-debug-session.html">
            
                <a href="../../9-develop-sym-debugger/2-核心调试逻辑/01-debug-session.html">
            
                    
                    9.2.01 Opening Debug Session
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2.3" data-path="../../9-develop-sym-debugger/2-核心调试逻辑/11-tinydbg_attach.html">
            
                <a href="../../9-develop-sym-debugger/2-核心调试逻辑/11-tinydbg_attach.html">
            
                    
                    9.2.11 tinydbg attach
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2.4" data-path="../../9-develop-sym-debugger/2-核心调试逻辑/12-tinydbg_attach_waitfor.html">
            
                <a href="../../9-develop-sym-debugger/2-核心调试逻辑/12-tinydbg_attach_waitfor.html">
            
                    
                    9.2.12 tinydbg attach+waitfor
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2.5" data-path="../../9-develop-sym-debugger/2-核心调试逻辑/13-tinydbg_exec.html">
            
                <a href="../../9-develop-sym-debugger/2-核心调试逻辑/13-tinydbg_exec.html">
            
                    
                    9.2.13 tinydbg exec
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2.6" data-path="../../9-develop-sym-debugger/2-核心调试逻辑/14-tinydbg_debug.html">
            
                <a href="../../9-develop-sym-debugger/2-核心调试逻辑/14-tinydbg_debug.html">
            
                    
                    9.2.14 tinydbg debug
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2.7" data-path="../../9-develop-sym-debugger/2-核心调试逻辑/15-tinydbg_core1.html">
            
                <a href="../../9-develop-sym-debugger/2-核心调试逻辑/15-tinydbg_core1.html">
            
                    
                    9.2.15 tinydbg core - part1
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2.8" data-path="../../9-develop-sym-debugger/2-核心调试逻辑/15-tinydbg_core2.html">
            
                <a href="../../9-develop-sym-debugger/2-核心调试逻辑/15-tinydbg_core2.html">
            
                    
                    9.2.15 tinydbg core - part2
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2.9" data-path="../../9-develop-sym-debugger/2-核心调试逻辑/16-tinydbg_connect.html">
            
                <a href="../../9-develop-sym-debugger/2-核心调试逻辑/16-tinydbg_connect.html">
            
                    
                    9.2.16 tinydbg connect
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2.10" data-path="../../9-develop-sym-debugger/2-核心调试逻辑/17-tinydbg_trace.html">
            
                <a href="../../9-develop-sym-debugger/2-核心调试逻辑/17-tinydbg_trace.html">
            
                    
                    9.2.17 tinydbg trace
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2.11" data-path="../../9-develop-sym-debugger/2-核心调试逻辑/21-disassemble.html">
            
                <a href="../../9-develop-sym-debugger/2-核心调试逻辑/21-disassemble.html">
            
                    
                    9.2.21 tinydbg> disass
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2.12" data-path="../../9-develop-sym-debugger/2-核心调试逻辑/22-breakpoint.html">
            
                <a href="../../9-develop-sym-debugger/2-核心调试逻辑/22-breakpoint.html">
            
                    
                    9.2.22 tinydbg> breakpoint
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2.13" data-path="../../9-develop-sym-debugger/2-核心调试逻辑/23-breakpoints.html">
            
                <a href="../../9-develop-sym-debugger/2-核心调试逻辑/23-breakpoints.html">
            
                    
                    9.2.23 tinydbg> breakpoints
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2.14" data-path="../../9-develop-sym-debugger/2-核心调试逻辑/24-clear.html">
            
                <a href="../../9-develop-sym-debugger/2-核心调试逻辑/24-clear.html">
            
                    
                    9.2.24 tinydbg> clear | toggle
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2.15" data-path="../../9-develop-sym-debugger/2-核心调试逻辑/25-clearall.html">
            
                <a href="../../9-develop-sym-debugger/2-核心调试逻辑/25-clearall.html">
            
                    
                    9.2.25 tinydbg> clearall
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2.16" data-path="../../9-develop-sym-debugger/2-核心调试逻辑/26-step.html">
            
                <a href="../../9-develop-sym-debugger/2-核心调试逻辑/26-step.html">
            
                    
                    9.2.26 tinydbg> next | step | stepi
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2.17" data-path="../../9-develop-sym-debugger/2-核心调试逻辑/27-continue.html">
            
                <a href="../../9-develop-sym-debugger/2-核心调试逻辑/27-continue.html">
            
                    
                    9.2.27 Continue Execution
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2.18" data-path="../../9-develop-sym-debugger/2-核心调试逻辑/28-pmem.html">
            
                <a href="../../9-develop-sym-debugger/2-核心调试逻辑/28-pmem.html">
            
                    
                    9.2.28 View Memory
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2.19" data-path="../../9-develop-sym-debugger/2-核心调试逻辑/29-regs.html">
            
                <a href="../../9-develop-sym-debugger/2-核心调试逻辑/29-regs.html">
            
                    
                    9.2.29 View Registers
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2.20" data-path="../../9-develop-sym-debugger/2-核心调试逻辑/30-call-frame.html">
            
                <a href="../../9-develop-sym-debugger/2-核心调试逻辑/30-call-frame.html">
            
                    
                    9.2.30 Call Frame Information
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2.21" data-path="../../9-develop-sym-debugger/2-核心调试逻辑/31-vars.html">
            
                <a href="../../9-develop-sym-debugger/2-核心调试逻辑/31-vars.html">
            
                    
                    9.2.31 Variables & Type System
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2.22" data-path="../../9-develop-sym-debugger/2-核心调试逻辑/32-how_listfunctions_work.html">
            
                <a href="../../9-develop-sym-debugger/2-核心调试逻辑/32-how_listfunctions_work.html">
            
                    
                    9.2.32 how ListFunctions work
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2.23" data-path="../../9-develop-sym-debugger/2-核心调试逻辑/32-funcs.html">
            
                <a href="../../9-develop-sym-debugger/2-核心调试逻辑/32-funcs.html">
            
                    
                    9.2.32 funcs
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2.24" data-path="../../9-develop-sym-debugger/2-核心调试逻辑/33-goroutines.html">
            
                <a href="../../9-develop-sym-debugger/2-核心调试逻辑/33-goroutines.html">
            
                    
                    9.2.33 Goroutines
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2.25" data-path="../../9-develop-sym-debugger/2-核心调试逻辑/34-multi-threads.html">
            
                <a href="../../9-develop-sym-debugger/2-核心调试逻辑/34-multi-threads.html">
            
                    
                    9.2.34 Tracing Multi-threaded Programs
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.9.3" data-path="../../9-develop-sym-debugger/3-高级功能扩展/">
            
                <a href="../../9-develop-sym-debugger/3-高级功能扩展/">
            
                    
                    9.3 Advanced Feature Extensions
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.9.3.1" data-path="../../9-develop-sym-debugger/3-高级功能扩展/100-howto_integrate_starlark.html">
            
                <a href="../../9-develop-sym-debugger/3-高级功能扩展/100-howto_integrate_starlark.html">
            
                    
                    9.3.100 Integrating starlark
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.3.2" data-path="../../9-develop-sym-debugger/3-高级功能扩展/101-howto_tracing_via_ebpf.html">
            
                <a href="../../9-develop-sym-debugger/3-高级功能扩展/101-howto_tracing_via_ebpf.html">
            
                    
                    9.3.101 Tracing with eBPF
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.3.3" data-path="../../9-develop-sym-debugger/3-高级功能扩展/102-howto_syntax_highlight.html">
            
                <a href="../../9-develop-sym-debugger/3-高级功能扩展/102-howto_syntax_highlight.html">
            
                    
                    9.3.102 Implementing Syntax Highlighting
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.3.4" data-path="../../9-develop-sym-debugger/3-高级功能扩展/103-howto_paging_output.html">
            
                <a href="../../9-develop-sym-debugger/3-高级功能扩展/103-howto_paging_output.html">
            
                    
                    9.3.103 Implementing Paged Output
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.3.5" data-path="../../9-develop-sym-debugger/3-高级功能扩展/104-howto_read_separate_dwarfdata.html">
            
                <a href="../../9-develop-sym-debugger/3-高级功能扩展/104-howto_read_separate_dwarfdata.html">
            
                    
                    9.3.104 Reading Separately Stored DWARF Data
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.3.6" data-path="../../9-develop-sym-debugger/3-高级功能扩展/105-howto_guess_substitutepath.html">
            
                <a href="../../9-develop-sym-debugger/3-高级功能扩展/105-howto_guess_substitutepath.html">
            
                    
                    9.3.105 Automatic Source File Path Mapping
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.3.7" data-path="../../9-develop-sym-debugger/3-高级功能扩展/106-howto_redirect_target_io.html">
            
                <a href="../../9-develop-sym-debugger/3-高级功能扩展/106-howto_redirect_target_io.html">
            
                    
                    9.3.106 Implementing Target Process IO Redirection
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.3.8" data-path="../../9-develop-sym-debugger/3-高级功能扩展/107-howto_customize_tinydbg.html">
            
                <a href="../../9-develop-sym-debugger/3-高级功能扩展/107-howto_customize_tinydbg.html">
            
                    
                    9.3.107 Supporting User Preferences
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.3.9" data-path="../../9-develop-sym-debugger/3-高级功能扩展/108-howto_accept_multiclient.html">
            
                <a href="../../9-develop-sym-debugger/3-高级功能扩展/108-howto_accept_multiclient.html">
            
                    
                    9.3.108 Supporting Multi-client Debug Mode
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.3.10" data-path="../../9-develop-sym-debugger/3-高级功能扩展/109-howto_transcript_debugging.html">
            
                <a href="../../9-develop-sym-debugger/3-高级功能扩展/109-howto_transcript_debugging.html">
            
                    
                    9.3.109 Supporting Debug Activity Logging
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="../../10-extras/">
            
                <a href="../../10-extras/">
            
                    
                    10 Mainstream Debugging Technology Analysis
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.10.1" data-path="../../10-extras/1-development-of-debugger.html">
            
                <a href="../../10-extras/1-development-of-debugger.html">
            
                    
                    10.1 Debugger Development History
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.2" data-path="../../10-extras/2-development-of-logging.html">
            
                <a href="../../10-extras/2-development-of-logging.html">
            
                    
                    10.2 Logging System Development History
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.3" data-path="../../10-extras/3-development-of-metrics.html">
            
                <a href="../../10-extras/3-development-of-metrics.html">
            
                    
                    10.3 Metrics System Development History
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.4" data-path="../../10-extras/4-development-of-tracing.html">
            
                <a href="../../10-extras/4-development-of-tracing.html">
            
                    
                    10.4 Tracing System Development History
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.5" data-path="../../10-extras/5-development-of-bisect.html">
            
                <a href="../../10-extras/5-development-of-bisect.html">
            
                    
                    10.5 Bisect Development History
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.6" data-path="../../10-extras/6-development-of-ebpf.html">
            
                <a href="../../10-extras/6-development-of-ebpf.html">
            
                    
                    10.6 eBPF Development History
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.7" data-path="../../10-extras/7-development-of-replay.html">
            
                <a href="../../10-extras/7-development-of-replay.html">
            
                    
                    10.7 Record and Replay Development History
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.8" data-path="../../10-extras/8-development-of-debug-dsys.html">
            
                <a href="../../10-extras/8-development-of-debug-dsys.html">
            
                    
                    10.8 Distributed Debugging Development History
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.11" data-path="../../11-thanks/">
            
                <a href="../../11-thanks/">
            
                    
                    11 Acknowledgments
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12" data-path="../../12-appendix/">
            
                <a href="../../12-appendix/">
            
                    
                    12 Appendix
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.12.1" data-path="../../12-appendix/1-go-programme-start.html">
            
                <a href="../../12-appendix/1-go-programme-start.html">
            
                    
                    12.1 Go Program Startup Process
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.2" data-path="../../12-appendix/2-auto-trace-cloned-threads.html">
            
                <a href="../../12-appendix/2-auto-trace-cloned-threads.html">
            
                    
                    12.2 Automatic Thread Tracing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.3" data-path="../../12-appendix/3-git-bisect.html">
            
                <a href="../../12-appendix/3-git-bisect.html">
            
                    
                    12.3 git bisect
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.4" data-path="../../12-appendix/80-go-tool-compile.html">
            
                <a href="../../12-appendix/80-go-tool-compile.html">
            
                    
                    12.10 Compilation Toolchain/compile
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.5" data-path="../../12-appendix/81-go-tool-asm.html">
            
                <a href="../../12-appendix/81-go-tool-asm.html">
            
                    
                    12.11 Compilation Toolchain/asm
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.6" data-path="../../12-appendix/82-go-tool-link.html">
            
                <a href="../../12-appendix/82-go-tool-link.html">
            
                    
                    12.12 Compilation Toolchain/link
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.7" data-path="../../12-appendix/90-why-buildid-loaded.html">
            
                <a href="../../12-appendix/90-why-buildid-loaded.html">
            
                    
                    12.13 More: GNU build-id+gobuildid
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.8" data-path="../../12-appendix/91-syntax-and-semantic-analysis.html">
            
                <a href="../../12-appendix/91-syntax-and-semantic-analysis.html">
            
                    
                    12.14 More: Syntax Analysis vs Semantic Analysis
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.9" data-path="../../12-appendix/92-why-gdb-uses-symtab.html">
            
                <a href="../../12-appendix/92-why-gdb-uses-symtab.html">
            
                    
                    12.15 More: Why GDB Uses Symbol Table+DWARF
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="../.." >8.5.3 Call Frame Information</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h2 id="call-frame-information-cfi">Call Frame Information (CFI)</h2>
<h3 id="function-introduction">Function Introduction</h3>
<p>The <strong>Call Frame Information (CFI)</strong> in DWARF debugging information is an important component that provides key information about function calls to debuggers. It records how register values are modified as the program counter (PC) changes during function calls and function execution. With this table, we can know the base address (CFA) of the current function, function parameters, return address, and then find the caller&apos;s stack frame. Because we also have unwinding rules for various registers, we can virtually unwind the call stack to a specified function frame.</p>
<h3 id="call-stack-unwinding">Call Stack Unwinding</h3>
<h4 id="cfi-stack-unwinding-process">CFI Stack Unwinding Process</h4>
<p>For CFI, we use the translation &quot;Call Frame Information&quot; rather than &quot;Call Stack Information&quot;. This is because CFI records how to unwind from the current function&apos;s frame to a specific caller&apos;s frame. When unwinding, we just need to find the corresponding function&apos;s FDE and execute the bytecode instructions in this FDE, rather than processing callers one by one until reaching the specified caller.</p>
<blockquote>
<p>ps: Although we can unwind the entire call stack, it&apos;s important to clear up misconceptions in conceptual understanding. In DWARF&apos;s design, you can unwind any function&apos;s frame as long as that function&apos;s frame actually exists. Usually we look at the caller&apos;s frame because caller-&gt;current called function are all executing on a specific tracee, and when the tracee stops we can conveniently observe its state. Even if we know that some thread executed a function and created the corresponding frame, if the debugger hasn&apos;t been tracking this thread, trying to unwind it would be meaningless.</p>
</blockquote>
<p>For example, in the CFI table, each machine instruction basically corresponds to one row: the first column is the instruction address, and other columns contain unwind operations for various registers before executing that instruction. Assuming the program goes from fn1-&gt;fn2-&gt; ... -&gt; fnN, with PCs from addr1 to current addrN. When we want to virtually unwind fn1&apos;s stack, how do we do it? We need to first find fn1&apos;s corresponding FDE, then use CIE=FDE.cie_pointer, execute CIE&apos;s initialization instructions and FDE&apos;s instructions until reaching the target instruction address in fn1. At this point, the corresponding register state will be correctly virtually restored to the state when fn1 executed that instruction.</p>
<p>OK, the debugger indeed needs to be able to view and modify the state of any active record (subroutine activation) on the call stack. We say stack frame (frame) and active record - these are not the same thing. The former emphasizes frame organization, while the latter emphasizes a new call record when a function is called. When a function call occurs, an activation contains at least:</p>
<ul>
<li>One valid instruction address in the called function, where either the program stopped when the debugger gained control (e.g., at a breakpoint), or where it called another callee, or where it was interrupted by an asynchronous event (e.g., a signal);</li>
<li>A memory area allocated on the stack called the &quot;call frame&quot; or &quot;function&apos;s stack frame&quot;. The starting address of the frame corresponding to this function is called the &quot;<strong>Canonical Frame Address (CFA)</strong>&quot;, which is actually the base address of the function&apos;s frame.</li>
<li>A set of registers used by the function when executing at a specific instruction location;</li>
</ul>
<blockquote>
<p>ps: For example, when function a calls function b, it first pushes b&apos;s parameters onto the stack (return value was also allocated on stack before go1.17, passed through registers after 1.17), then pushes b&apos;s return address (i.e., rip value), then pushes rbp, ... For b&apos;s stack frame, CFA is its frame&apos;s base address, which is actually the caller&apos;s rsp value before pushing rip.</p>
</blockquote>
<p>To be able to view or modify a function frame that&apos;s not at the top of the stack frame, the debugger must be able to &quot;virtually unwind&quot; the entire call stack until the target function frame is unwound. The unwinding process starts from the current function frame and instruction address, looks up the CFI information table, finds the corresponding record, then executes the corresponding register unwinding rules in reverse order until the target stack frame is unwound.</p>
<p>Think about the gdb debugging process - we can see the call frames through bt, then select a specific frame using frame N. This is a process of virtually unwinding the call frame. The register state in the Nth frame is calculated and stored somewhere, for example rsp and rbp are recalculated and stored somewhere, and used to calculate variable addresses for subsequent print operations, so we can see the Nth frame&apos;s function parameters, local variables, and register values. Why do we say it&apos;s virtual unwinding? It means that the register unwinding rules are only used to recalculate the register values at that time, but they are not set back into the registers, the process state is not modified, it just appears as if we&apos;ve returned to the corresponding caller&apos;s stack frame... That&apos;s why we say virtually unwind.</p>
<p>Usually, when a function is called, a set of registers is specified and their state is saved. If the called function wants to use a register, it must save that register&apos;s value to the stack frame at function entry and restore it at function exit.</p>
<ul>
<li>The code that adjusts frame size (for local variables) and saves register state on the call frame is called the function prologue;</li>
<li>The code that restores register state and destroys the call frame is called the function epilogue.</li>
</ul>
<p>Usually, the prologue code is actually at the beginning of the function, while the epilogue code is at the end of the function.</p>
<h4 id="architecture-independent-encoding">Architecture-Independent Encoding</h4>
<p>For stack unwinding operations, we need to know where registers are saved and how to calculate the caller&apos;s CFA and code location. When considering architecture-independent information encoding, there are some special considerations:</p>
<ul>
<li>Subroutine (function) prologue and epilogue code are not always in two different blocks at the beginning and end of the subroutine. Usually the subroutine epilogue code will be copied to each return operation location. Sometimes, the compiler will also split up register save/unsave operations and move them to where the subroutine code needs them;</li>
<li>The compiler will use different ways to manage the call frame, sometimes through a stack pointer, sometimes not;</li>
<li>As the subroutine prologue and epilogue code executes, the algorithm for calculating CFA also changes (by definition, the CFA value doesn&apos;t change);</li>
<li><p>Some subroutine calls don&apos;t have a call frame (e.g., may be optimized away through &quot;tail recursion&quot;);</p>
<blockquote>
<p>For information about compiler optimization of tail recursion, you can refer to the blog post: <a href="http://www.ruanyifeng.com/blog/2015/04/tail-call.html" target="_blank">tail recursion call optimization</a>. The current Go compiler doesn&apos;t support tail recursion optimization, but gcc does.</p>
</blockquote>
</li>
<li>Sometimes a register&apos;s value is saved in another register, but the latter may conventionally not need to be stored in the subroutine prologue;</li>
<li>Some architectures have special instructions that can perform part or all of register management in a single instruction, leaving some special information on the stack to indicate how registers should be saved;</li>
<li>Some architectures handle return address values specially. For example, in some architectures, the call instruction ensures the call address&apos;s lower two bits are zero, while the return instruction ignores these bits. This leaves two storage bits available for other uses, which must be handled specially.</li>
</ul>
<h3 id="cfi-detailed-design">CFI Detailed Design</h3>
<h4 id="cfi-table-structure-design">CFI Table Structure Design</h4>
<p>DWARF defines architecture-independent basic elements to support &quot;virtual unwinding&quot; of call frames. These basic elements can record how register state is saved and restored during subroutine calls. For certain specific machines, they may have architecture-specific information defined by ABI committees, hardware vendors, or compiler manufacturers, which needs to supplement DWARF&apos;s basic elements.</p>
<p>The table structure described by CFI is shown in the figure below:</p>
<p><img src="assets/image-20191229130341692.png" alt="image-20191229130341692" style="zoom:5%;"></p>
<ul>
<li>Column 1, instruction address. Represents the address of an instruction in the program (in shared library files, instruction addresses are offsets relative to the start address);</li>
<li>Column 2, CFA (Canonical Frame Address), which is simply the base address of the Callee&apos;s stack frame. The CFA column&apos;s address calculation rule can be calculated by combining registers and offsets, or by DWARF expressions.</li>
<li><p>Other columns, virtual unwinding rules for each register; the register rules here include:</p>
<ul>
<li>undefined, this rule indicates that the corresponding register has no recoverable value in the previous stack frame. Usually, this means the relevant register&apos;s state was not saved when calling the callee;</li>
<li>same value, this rule indicates that the corresponding register&apos;s value is the same as in the previous stack frame. Usually, this means the relevant register&apos;s state was saved when calling the callee, but not modified;</li>
<li>offset(N), this rule indicates that the corresponding register&apos;s value is saved at address CFA+N, where CFA is the current CFA value and N is a signed offset;</li>
<li>val_offset(N), this rule indicates that the corresponding register&apos;s value is the value at CFA+N, where CFA is the current CFA value and N is a signed offset;</li>
<li>register(R), this rule indicates that the corresponding register&apos;s value is saved in another register R;</li>
<li>expression(E), this rule indicates that the corresponding register&apos;s value is saved at the memory address corresponding to DWARF expression E;</li>
<li>val_expression(E), this rule indicates that the corresponding register&apos;s value is the value of DWARF expression E;</li>
<li>architectural, this rule is not defined in the current specification, it is defined by the augmenter;</li>
</ul>
</li>
</ul>
<p>If we really stored one record for each instruction in the above CFI information table, the table space would be very large! To efficiently store this information, CFI adopts a compression strategy similar to the line number table: encoding the information as a bytecode instruction sequence. Although the complete CFI table is large, since state changes between adjacent instructions are usually small, we can still store based on differences and increments. This encoding method allows CFI to maintain a fairly compact storage format. When reconstructing the CFI table matrix, these instructions are interpreted and executed by a specialized CFI state machine.</p>
<p>The above CFI information table is encoded in the &quot;<strong>.debug_frame</strong>&quot; section. Entries in the .debug_frame section are aligned relative to the start of the section by multiples of the address size, and appear in two forms:</p>
<ul>
<li>Common Information Entry (CIE);</li>
<li>Frame Descriptor Entry (FDE);</li>
</ul>
<blockquote>
<p>ps: If a function&apos;s code segment address range is not continuous, there may be multiple CIEs and FDEs.</p>
</blockquote>
<p>Building the CFI table structure requires CIE and FDE, because the bytecode program for building the CFI table structure is stored in them. We need to first introduce CIE and FDE content before explaining how to generate the CFI table.</p>
<h4 id="common-information-entry-cie">Common Information Entry (CIE)</h4>
<p>Each compilation unit has one CIE, and the information in each Common Information Entry (CIE) may be shared by many Frame Descriptor Entries (FDEs). Each non-empty .debug_frame section contains at least one CIE, and each CIE contains the following fields:</p>
<ol>
<li>length (initial length), constant, indicates the size of this CIE structure (number of bytes), not including the field itself. The number of bytes occupied by the length field plus the value of length must be aligned according to address size;</li>
<li>CIE_id (4 bytes or 8 bytes), constant, used for CIEs and FDEs;</li>
<li>version(ubyte), version number, this value is related to CFI information, independent of DWARF version;</li>
<li>augmentation (UTF-8 string), null-terminated UTF-8 string, used to mark extension information for the current CIE and FDEs that use it</li>
<li>address_size (ubyte), number of bytes occupied by target machine addresses in this CIE and other FDEs that use this CIE. If there is a compilation unit in this frame, its address size must be the same as the address size here;</li>
<li>segment_size (ubyte), number of bytes occupied by segment selectors in this CIE and other FDEs that use this CIE;</li>
<li>code_alignment_factor (unsigned LEB128), constant, instruction address offset = operand * code_alignment_factor;</li>
<li>data_alignment_factor (signed LEB128), constant, offset = operand * data_alignment_factor;</li>
<li>return_address_register (unsigned LEB128), constant, indicates where the return address is stored, may be a physical register or memory</li>
<li>initial_instructions (array of ubyte), a series of rules, used to indicate how to create the initial settings of the CFI information table;
Before executing initial instructions, the default generation rule for all columns is undefined, however, the ABI authoring body or compilation system authoring body can also specify other default rules for some or all columns;</li>
<li>padding (array of ubyte), byte padding, fills the structure with DW_CFA_nop instructions to make the CIE structure size meet the length requirement. The length value plus field bytes must be aligned according to address size;</li>
</ol>
<h4 id="frame-descriptor-entry-fde">Frame Descriptor Entry (FDE)</h4>
<p>Each function has one FDE, and a Frame Descriptor Entry (FDE) contains the following fields:</p>
<ol>
<li>length (initial length), constant, indicates the number of bytes of the header and instruction stream corresponding to this function, not including the field itself. The size of the length field (number of bytes) plus the length value must be a multiple of address size (defined in the FDE&apos;s referenced CIE), i.e., aligned by address size;</li>
<li>CIE_pointer (4 or 8 bytes), constant, offset of the CIE referenced by this FDE in .debug_frame;</li>
<li>initial_location (segment selector, and target address), instruction address corresponding to the first instruction of this table entry. If segment_size (defined in referenced CIE) is non-zero, a segment selector needs to be added before initial_location;</li>
<li>address_range (target address), number of bytes occupied by program instructions described by this FDE;</li>
<li>instructions (array of ubyte), instruction sequence contained in the FDE, described later;</li>
<li>padding (array of ubyte), byte padding, fills the structure with DW_CFA_nop instructions to make the FDE structure size meet the length field requirement;</li>
</ol>
<h4 id="bytecode-instruction-classification">Bytecode Instruction Classification</h4>
<p>Call Frame Instructions, each instruction can contain zero or more operands, some operands are encoded into the opcode. Some instruction operands are encoded through DWARF expressions. The initialization instruction sequence in CIE and instruction sequence in FDE are executed to create the CFI table structure.</p>
<p>The call frame instructions here include the following categories:</p>
<ul>
<li>CFI table row creation instructions, used to create a row in the table;</li>
<li>CFI table CFA definition instructions, used to define the CFA calculation rule for the current row;</li>
<li>CFI table register rule instructions, used to define unwinding rules for other registers in the current row;</li>
<li>CFI table row state instructions, ability to save register state to stack and retrieve it;</li>
<li>CFI table row padding instructions, fill with nop, do nothing;</li>
</ul>
<h5 id="cfi-table-row-creation-instructions">CFI Table Row Creation Instructions</h5>
<ol>
<li>DW_CFA_set_loc
The DW_CFA_set_loc instruction takes a single operand representing the target address. The required operation is to create a new table row using the specified address as the new location. All other values in the new row are initially the same as the current row. The new location value is always greater than the current location value. If the segment_size field of this FDE&apos;s CIE is not zero, a segment selector needs to be added before the initial location.</li>
<li>DW_CFA_advance_loc
The DW_CFA_advance instruction takes a single operand (encoded in the opcode) representing a constant increment. The required operation is to create a new table row using a location value calculated by taking the current entry&apos;s location value and adding delta * code_alignment_factor. All other values in the new row are initially the same as the current row.</li>
<li>DW_CFA_advance_loc1
The DW_CFA_advance_loc1 instruction takes a single ubyte operand representing a constant increment. This instruction is the same as DW_CFA_advance_loc except for the encoding and size of the increment operand.</li>
<li>DW_CFA_advance_loc2
The DW_CFA_advance_loc2 instruction takes a single uhalf operand representing a constant increment. This instruction is the same as DW_CFA_advance_loc except for the encoding and size of the increment operand.</li>
<li>DW_CFA_advance_loc4
The DW_CFA_advance_loc4 instruction takes a single uword operand representing a constant increment. This instruction is the same as DW_CFA_advance_loc except for the encoding and size of the increment operand.</li>
</ol>
<h5 id="cfi-table-cfa-definition-instructions">CFI Table CFA Definition Instructions</h5>
<ol>
<li>DW_CFA_def_cfa
The DW_CFA_def_cfa instruction has two operands, both unsigned LEB128 encoded, representing register number and non-factored offset respectively. This instruction defines the CFA rule using the provided register and offset.</li>
<li>DW_CFA_def_cfa_sf
The DW_CFA_def_cfa_sf instruction takes two operands: an unsigned LEB128 value representing register number and a signed LEB128 factored offset. This instruction is the same as DW_CFA_def_cfa except that the second operand is signed factored. The resulting offset is factored_offset * data_alignment_factor.</li>
<li>DW_CFA_def_cfa_register
The DW_CFA_def_cfa_register instruction takes a single unsigned LEB128 operand representing register number. This instruction defines the current CFA rule to use the provided register (but keeps the old offset). This operation is only valid when the current CFA rule is defined to use a register and offset.</li>
<li>DW_CFA_def_cfa_offset
The DW_CFA_def_cfa_offset instruction takes a single unsigned LEB128 operand representing a non-factored offset. This instruction defines the current CFA rule to use the provided offset (but keeps the old register). This operation is only valid when the current CFA rule is defined to use a register and offset.</li>
<li>DW_CFA_def_cfa_offset_sf
The DW_CFA_def_cfa_offset_sf instruction takes a signed LEB128 operand representing a factored offset. This instruction is the same as DW_CFA_def_cfa_offset except that the operand is signed factored. The resulting offset is factored_offset * data_alignment_factor. This operation is only valid when the current CFA rule is defined to use a register and offset.</li>
<li>DW_CFA_def_cfa_expression
The DW_CFA_def_cfa_expression instruction takes a single operand encoded as a DW_FORM_exprloc value representing a DWARF expression. This instruction uses the expression as a way to calculate the current CFA.</li>
</ol>
<blockquote>
<p>ps: For restrictions on available DWARF expression operators, see DWARF v4 section 6.4.2.</p>
</blockquote>
<h5 id="cfi-table-register-rule-instructions">CFI Table Register Rule Instructions</h5>
<ol>
<li>DW_CFA_undefined
The DW_CFA_undefined instruction takes a single unsigned LEB128 operand representing register number. This instruction specifies that the register unwind rule is set to &quot;undefined&quot;.</li>
<li>DW_CFA_same_value
The DW_CFA_same_value instruction takes a single unsigned LEB128 operand representing register number. This instruction sets the specified register unwind rule to &quot;same&quot;.</li>
<li>DW_CFA_offset
The DW_CFA_offset instruction takes two operands: a register number (encoded using the opcode) and an unsigned LEB128 constant (factored offset). This instruction changes the unwind rule for the register indicated by the specified register number to the offset(N) rule, where N&apos;s value is factored_offset * data_alignment_factor.</li>
<li>DW_CFA_offset_extended
The DW_CFA_offset_extended instruction takes two unsigned LEB128 operands representing register number and factored offset. This instruction is the same as DW_CFA_offset except for the encoding and size of the register operand.</li>
<li>DW_CFA_offset_extended_sf
The DW_CFA_offset_extended_sf instruction takes two operands: an unsigned LEB128 value representing register number and a signed LEB128 encoded factored offset. This instruction is the same as DW_CFA_offset_extended except that the second operand is a signed factored offset. The resulting offset is factored_offset * data_alignment_factor.</li>
<li>DW_CFA_val_offset
The DW_CFA_val_offset instruction takes two unsigned LEB128 operands representing register number and factored offset. The required operation is to change the register rule for the register indicated by the register number to the val_offset(N) rule, where N&apos;s value is factored_offset * data_alignment_factor.</li>
<li>DW_CFA_val_offset_sf
The DW_CFA_val_offset_sf instruction takes two operands: an unsigned LEB128 value representing register number and a signed LEB128 factored offset. This instruction is the same as DW_CFA_val_offset except that the second operand is a signed factored offset. The resulting offset is factored_offset * data_alignment_factor.</li>
<li>DW_CFA_register
The DW_CFA_register instruction takes two unsigned LEB128 operands representing register numbers. This instruction sets the first register&apos;s unwind rule to register(R), where R is the second register.</li>
<li><p>DW_CFA_expression
The DW_CFA_expression instruction takes two operands: an unsigned LEB128 value representing register number and a DW_FORM_block value representing a DWARF expression. This instruction changes the unwind rule for the register indicated by the register number to the expression(E) rule, where E is the DWARF expression.</p>
<blockquote>
<p>Before executing the DWARF expression, the current CFA value must be pushed onto the operation stack. After the DWARF expression execution completes, the top of the stack is the result. For restrictions on available DWARF expression operators, see DWARF v4 section 6.4.2.</p>
</blockquote>
</li>
<li>DW_CFA_val_expression
The DW_CFA_val_expression instruction takes two operands: an unsigned LEB128 value representing register number and a DW_FORM_block value representing a DWARF expression. This instruction changes the unwind rule for the register indicated by the LEB128 value to the val_expression(E) rule, where E is the DWARF expression.</li>
<li>DW_CFA_restore
The DW_CFA_restore instruction takes a single operand (encoded in the opcode) representing register number. This instruction changes the specified register unwind rule to the rule assigned to it by initial_instructions in the CIE.</li>
<li>DW_CFA_restore_extended
The DW_CFA_restore_extended instruction takes a single unsigned LEB128 operand representing register number. This instruction is the same as DW_CFA_restore except for the encoding and size of the register operand.</li>
</ol>
<h5 id="cfi-table-row-state-instructions">CFI Table Row State Instructions</h5>
<p>The next two instructions provide the ability to save register state to stack and retrieve it. They are useful when the compiler needs to move function epilogue code into return locations in the function body.</p>
<ol>
<li>DW_CFA_remember_state
The DW_CFA_remember_state instruction takes no operands, it pushes each register&apos;s rule set onto an implicit stack.</li>
<li>DW_CFA_restore_state
The DW_CFA_restore_state instruction takes no operands, it pops the rule set from the implicit stack and places it in the current row.</li>
</ol>
<h5 id="cfi-table-byte-padding-instruction">CFI Table Byte Padding Instruction</h5>
<ol>
<li>DW_CFA_nop
The DW_CFA_nop instruction has no operands and no required operation. It is used as a padding byte to make the CIE or FDE size appropriate.</li>
</ol>
<h3 id="two-uses-of-cfi">Two Uses of CFI</h3>
<h4 id="call-frame-instruction-usage">Call Frame Instruction Usage</h4>
<p>The main use of Call Frame Information (CFI) is to perform stack unwinding during program execution to reconstruct the function call chain. To achieve this goal, we need to be able to determine the register state at any execution point. Below we introduce how to use CFI instructions to obtain this information.</p>
<p>To <strong>determine the virtual unwind rule set for a given location (L1)</strong>, first search for the FDE containing that location in FDE headers. This can be done by comparing the initial_location and address_range values in FDE headers.</p>
<p>Once the corresponding FDE is found, the unwind rule set for that location can be determined by following these steps:</p>
<ol>
<li>Initialize the register set by reading the initial_instructions field of the CIE associated with the FDE;</li>
<li>Read and process the FDE&apos;s instruction sequence until encountering an instruction with address greater than L1 (DW_CFA_advance_loc, DW_CFA_set_loc), or reaching the end of the instruction stream;</li>
<li>If a DW_CFA_advance_loc or DW_CFA_set_loc instruction is encountered, calculate a new location value (L2). If L1 &gt;= L2, process that instruction and return to step 2 to continue execution;</li>
<li>The end of the instruction stream can be treated as a DW_CFA_set_loc(initial_location+address_range) instruction. Note that if after executing to the end of the instruction stream, if L2&lt;L1, then the FDE format is incorrect;</li>
</ol>
<p>By executing the above steps, we can obtain the virtual unwind rule set for location L1, which describes how to restore all register states at that location. For specific examples, see DWARF v4 2 Appendix D.6.</p>
<h4 id="call-frame-calling-address">Call Frame Calling Address</h4>
<p>When performing stack unwinding, the debugger usually wants to obtain the <strong>instruction address at function call time</strong>. This information may not exist (e.g., tail recursion eliminates function calls). But usually, CFI will specify a register (specified in CIE) to store the function call&apos;s return address.</p>
<p>If a return address register is defined in the CFI table and its rule is undefined (e.g., defined by DW_CFA_undefined), then there is no return address, no calling address, and the virtual unwinding of the call frame is complete.</p>
<p>In most cases, the return address is in the same context as the calling address, but this doesn&apos;t have to be the case, especially if the compiler somehow knows the call will never return. The &quot;return address&quot; context may be in a different line, in a different lexical block, or at the end of the calling function. If the user assumes the return address is in the same context as the calling address, the unwinding may fail.</p>
<p>For architectures with fixed-length instructions where the return address immediately follows the call instruction, a simple solution is to subtract the instruction length from the return address to get the call instruction&apos;s address. For architectures with variable-length instructions (e.g., x86), this is not possible. However, <strong>subtracting 1 from the return address, while not guaranteed to provide the exact calling address, usually generates an address in the same context as the calling address, which is usually sufficient</strong>. Why is it sufficient? Because at least we can determine the same source location, which is enough.</p>
<blockquote>
<p>ps: So, the Calling Address calculated is Callee&apos;s function return address - 1. Subtracting 1 from this address value (e.g., Call is a multi-byte instruction), while not giving the exact instruction address before the function call, at least helps us determine the source location and stack frame when the function call occurred, so we can view the source location and context information at that time, which is usually sufficient.</p>
<p>When we use <code>gdb&gt; bt</code> to view all current stack frames and select a frame using the <code>frame</code> command, we don&apos;t care what the exact calling address is, as long as we can restore the corresponding source location and stack frame context at call time, that&apos;s sufficient.</p>
<p>ps: The calling address and return address not being in the same context may be a bit confusing, but if you&apos;ve seen the Linux kernel startup code, you&apos;ll understand this point very easily. Linux kernel head.s needs to do a lot of work to bridge the transition from BIOS 16-bit operation mode to Linux 32/64-bit mode, such as supporting 32-bit/64-bit addressing, rebuilding 32-bit/64-bit interrupt vector tables, rebuilding GDT, etc., before finally calling the Linux kernel&apos;s main function. Because this main function will never return, head.s actually simulates call main through ret main address. The manifestation is that the function calling address and return address are not in the same context at all.</p>
<p>This is just an example to help everyone understand this point, but it&apos;s not to say that this example&apos;s scenario completely covers or equals the above point.</p>
</blockquote>
<h3 id="example-demonstration">Example Demonstration</h3>
<h4 id="machine-information">Machine Information</h4>
<p>The example below assumes a RISC machine, Motorola 88000.</p>
<ul>
<li>Memory is byte-addressable;</li>
<li>All instructions are 4-byte fixed length and word-aligned;</li>
<li>Instruction operands are generally organized as: <code>&lt;destination.reg&gt;, &lt;source.reg&gt;, &lt;constant&gt;</code></li>
<li>Memory addresses for load and store instructions are calculated by adding the value in source register source.reg and constant const;</li>
<li>Has 8 4-byte registers:
R0: Always 0;
R1: Saves return address during function calls;
R2-R3: Temporary registers, don&apos;t need to save original values during function calls;
R4-R6: Need to save original values during function calls;
R7: Saves stack pointer value;</li>
<li>Stack grows from high to low addresses;</li>
<li>Architecture ABI committee specifies stack pointer <code>(R7)</code> is the same as CFA;</li>
</ul>
<h4 id="machine-instructions-for-foo">Machine Instructions for foo</h4>
<p>Below are two machine instruction fragments for function foo, corresponding to the function prologue and epilogue parts respectively. Besides using stack pointer, it also uses frame pointer. The first column is instruction address, <code>&lt;fs&gt;</code> represents stack frame size (in bytes), which is 12 bytes in this example.</p>
<p><img src="assets/image-20191229171656174.png" alt="image-20191229171656174" width="600px"></p>
<h4 id="cfi-table-for-foo">CFI Table for foo</h4>
<p>The CFI information table corresponding to Figure 63 is shown in Figure 64 below, and the corresponding code fragment in .debug_frame section is shown in Figure 65.</p>
<p>We used the following annotation symbols in Figure 64 CFI information table, please understand their meanings first.</p>
<ol>
<li>R8 stores return address</li>
<li>s = same_value unwind rule</li>
<li>u = undefined unwind rule</li>
<li>rN = register(N) unwind rule</li>
<li>cN = offset(N) unwind rule</li>
<li>a = architectural unwind rule</li>
</ol>
<p><img src="assets/image-20191229172236863.png" alt="image-20191229172236863" width="600px"></p>
<h4 id="cie-initial-instructions-guide-creation-of-first-row-in-cfi">CIE Initial Instructions Guide Creation of First Row in CFI</h4>
<p>The first row of the CFI information table is created by the initial instructions in the CIE referenced by FDE.CIE_Pointer of the current called function foo. Therefore, to understand why the first row is <code>foo [R7]+0 s u u u s s s a r1</code>, we need to look at the CIE. Figure 65 below gives the CIE description.</p>
<p>The CIE specifies that R8 is the return address register. This machine Motorola 88000 specifies that R1 saves the return address during function calls, so R8&apos;s value is actually in R1. After clarifying this point, let&apos;s see how the initial instructions part in CIE guides the creation of the first row in the CFI information table.</p>
<p>Before foo&apos;s first instruction executes, the PC value is the memory address corresponding to the foo symbol:</p>
<ul>
<li><p>DW_CFA_def_cfa(7,0) specifies CFA=[R7]+0, indicating that foo&apos;s canonical frame address CFA is the caller&apos;s stack pointer value, i.e., R7&apos;s value (at this point <code>R7=R7-&lt;fs&gt;</code>, execution hasn&apos;t started yet, stack frame hasn&apos;t been allocated for foo), giving us <code>foo [R7]+0</code>;</p>
<blockquote>
<p>ps: Usually function call instructions like call push the return address (PC value) onto the call stack as the return address for after function execution completes.</p>
</blockquote>
</li>
<li>DW_CFA_same_value(0) specifies that register R0 is always 0, using same unwind rule, which makes sense, giving us <code>foo [R7]+0 s</code>;</li>
<li><p>DW_CFA_undefined(1)/(2)/(3) specifies that registers R1/R2/R3 use undefined unwind rule. R2 and R3 are temporary registers that don&apos;t need saving, so using undefined rule is fine. R1 actually saves the return address, and this program doesn&apos;t use R1 for other purposes, so it&apos;s also undefined. This gives us <code>foo [R7]+0 s u u u</code>;</p>
<blockquote>
<p>If prologue code later uses R1, epilogue would have other unwind rules to restore it, but there aren&apos;t any, indicating R1 isn&apos;t used at all;</p>
</blockquote>
</li>
<li>DW_CFA_same_value(4)/(5)/(6) specifies that registers R4/R5/R6 use same unwind rule. R4, R5, and R6 are registers that need their state saved, so same unwind rule is used here. This gives us <code>foo [R7]+0 s u u u s s s</code>;</li>
<li>R7 originally saves the stack pointer value, it&apos;s also special, the architecture ABI committee specifies it&apos;s the same as CFA, so architectural unwind rule is used here, giving us <code>foo [R7]+0 s u u u s s s a</code>;</li>
<li>DW_CFA_register(8,1) specifies that register R8 is stored in register R1, because R8 represents the return address, and R1 records the return address, so register(8,1) is used. This gives us <code>foo [R7]+0 s u u u s s s a r1</code>;</li>
<li>Next are padding instructions, filling the CIE structure size to meet the CIE.length requirement, which is unrelated to building the CFI information table, so we can ignore it.</li>
</ul>
<p>After the above instructions execute, the first row in the CFI information table is built: <code>foo [R7]+0 s u u u s s s a r1</code>.</p>
<p><img src="assets/image-20191229172436047.png" alt="image-20191229172436047" width="600px"></p>
<h4 id="fde-instruction-sequence-guides-creation-of-rows-2-3-and-n-in-cfi-table">FDE Instruction Sequence Guides Creation of Rows 2, 3, and n in CFI Table</h4>
<p>Then looking at the foo machine instruction code fragments, let&apos;s see what the instruction sequence in FDE corresponding to the prologue and epilogue parts should look like, and what effect these instructions have on the CFI table.</p>
<p>Recalling the machine instructions for foo prologue and epilogue fragments:</p>
<p><img src="assets/image-20191229171656174.png" alt="image-20191229171656174" width="600px"></p>
<p>Figure 66 below shows the instruction sequence in FDE corresponding to the machine instructions in Figure 63. Figure 66 uses the following annotations:</p>
<ol>
<li><code>&lt;fs&gt;</code> = stack frame size</li>
<li><code>&lt;caf&gt;</code> = code alignment factor</li>
<li><code>&lt;daf&gt;</code> = data alignment factor</li>
</ol>
<p><img src="assets/IMG_0050.JPG" alt="IMG_0050" width="600px"></p>
<p>You must have questions about how the instruction sequence in FDE is generated. Each machine instruction in Figure 63 has a different address and affects different registers. Actually, it&apos;s just generating corresponding CFI table building instructions based on each machine instruction&apos;s specific actions, such as CFI table row create rules, and unwind rules for affected registers, that&apos;s all. Below we&apos;ll explain how the instruction sequence in FDE is built based on the machine instructions in Figure 63, and what it looks like reflected in the CFI information table. After reading this, you&apos;ll have a clear understanding of CFI table building!</p>
<p>First row of CFI information table: <code>foo [R7]+0 s u u u s s s a r1</code>, it indicates how to calculate CFA and how to restore various registers when PC is at address foo. Below we explain how each instruction operation in the code is converted to corresponding CFI row rule set.</p>
<ul>
<li><p><code>foo sub R7, R7, &lt;fs&gt;</code></p>
<p>R7 stores the stack pointer value, after instruction executes <code>R7=R7-&lt;fs&gt;</code>, equivalent to allocating a <code>&lt;fs&gt;</code> sized stack frame for foo to use. Since CFI previously used R7 and offset as the rule for calculating CFA, and R7&apos;s value decreased by <code>&lt;fs&gt;</code> here, we need to adjust the CFA rule. First we need a row create rule, then a CFA adjustment rule, which are DW_CFA_advance_loc(1) and DW_CFA_def_cfa_offset(12) in Figure 66 below. Since no other register adjustments are involved, these two unwind rules are enough.</p>
<p>Here DW_CFA_advance_loc(1) means instruction address advances by code_alignment_factor <em> 1 = 4 </em> 1 = 4, indicating that after this machine instruction executes PC=foo+4. DW_CFA_def_cfa_offset(12) means the register in CFA calculation rule is still R7, but offset changes from 0 to +12.</p>
<p>So the second row of CFI table is <code>foo+4 [R7]+fs s u u u s s s a r1</code>, where fs=12.</p>
<blockquote>
<p>Therefore each row <code>addr : unwind rule set</code> in the CFI information table indicates the unwind rule set when PC=addr (instruction at this address is to be executed).</p>
</blockquote>
</li>
<li><p><code>foo+4 store R1, R7, (&lt;fs&gt;-4)</code></p>
<p>R1 stores the return address, <code>R7+&lt;fs&gt;-4</code> is the highest 4 bytes of foo&apos;s stack frame. This instruction intends to store the return address of foo function call (R1 value) at this location. Since R8 in the CFI information table is used to store the return address, we need to adjust R8&apos;s unwind rule. We need two operations, first a row create rule, then an R8 unwind rule.</p>
<p>DW_CFA_advance_loc(1), DW_CFA_offset(8,1), DW_CFA_advance_loc(1) increases instruction address offset by <code>code_alignment_factor * 1 = 4 * 1</code>, i.e., addr = foo+8. DW_CFA_offset(8,1) means register R8 is stored at <code>current CFA + offset data_alignment_factor * 1 = CFA + (-4) * 1 = CFA-4</code>, i.e., unwind rule becomes c-4.</p>
<p>This gives us the second row of CFI table <code>foo+8 [R7]+fs s u u u s s s a c-4</code>.</p>
<blockquote>
<p>data_alignment_factor=-4, this is defined in CIE.</p>
</blockquote>
</li>
<li><p><code>foo+8 store R6, R7, (&lt;fs&gt;-8)</code></p>
<p>Here we want to store R6 register&apos;s value to the 4~8 byte position of foo&apos;s stack frame, affecting R6 register&apos;s unwind rule. We need two operations, one row create rule, one adjustment of R6&apos;s unwind rule.</p>
<p>DW_CFA_advance_loc(1), DW_CFA_offset(6,2) means instruction address <code>addr+=code_alignment_factor * 1</code>, i.e., foo+12, and R6&apos;s value is stored at <code>current CFA + data_alignment_factor*2 = CFA+(-4)*2 = CFA-8</code> position, CFA-8 represents exactly the 4~8 byte position of foo&apos;s stack frame.</p>
<p>This gives us the third row of CFI table <code>foo+12 [R7]+fs s u u u s s c-8 a c-4</code>.</p>
</li>
<li>...</li>
<li>Other assembly instructions&apos; corresponding operations in FDE and explanations won&apos;t be listed one by one, generally following the above approach.</li>
</ul>
<p>At this point, we should understand the following process clearly: &quot;<strong>source code -&gt; machine instructions -&gt; generation of instruction sequence in CIE+FDE -&gt; process of CIE and FDE instructions building CFI table</strong>&quot;. As for <code>CFI table usage</code>, such as given an instruction address L1, further determining its corresponding CFA or return address, these are simpler and were covered earlier.</p>
<p>This concludes the introduction of the Call Frame Information table.</p>
<h3 id="conclusion">Conclusion</h3>
<p>This article detailed the Call Frame Information (CFI) in DWARF debugging information, including its basic concepts, functions, table structure design (CIE and FDE), and bytecode instruction system. Through a concrete example on the Motorola 88000 architecture, it demonstrated the complete process from source code to machine instructions to CFI table building, explaining how to build the CFI table through instruction sequences in CIE and FDE, and how to use this information for stack unwinding and call stack expansion. This knowledge is important for understanding debugger working principles and program execution processes.</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="2-lineno-table.html" class="navigation navigation-prev " aria-label="Previous page: 8.5.2 Line Number Table Information">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="4-macro-info.html" class="navigation navigation-next " aria-label="Next page: 8.5.4 Macro Information">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"8.5.3 Call Frame Information","level":"1.8.5.3","depth":3,"next":{"title":"8.5.4 Macro Information","level":"1.8.5.4","depth":3,"path":"8-dwarf/5-other/4-macro-info.md","ref":"8-dwarf/5-other/4-macro-info.md","articles":[]},"previous":{"title":"8.5.2 Line Number Table Information","level":"1.8.5.2","depth":3,"path":"8-dwarf/5-other/2-lineno-table.md","ref":"8-dwarf/5-other/2-lineno-table.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":["md-toc"],"pluginsConfig":{"intopic-toc":{"selector":".markdown-section h1, .markdown-section h2, .markdown-section h3, .markdown-section h4, .markdown-section h5, .markdown-section h6","visible":true,"label":{"en":"In This Article","zh":"本文目录"}},"md-toc":{"label":"In this article","selector":".markdown-section h2","visible":true},"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"8-dwarf/5-other/3-callframe-info.md","mtime":"2025-06-15T11:31:05.829Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2025-06-15T18:01:33.391Z"},"basePath":"../..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../../gitbook/gitbook.js"></script>
    <script src="../../gitbook/theme.js"></script>
    
        
        <script src="../../gitbook/gitbook-plugin-md-toc/anchor.min.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-md-toc/gumshoe.min.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-md-toc/plugin.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>



<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>9.2.15 tinydbg core - part2 Â· GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="../../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-md-toc/style.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="16-tinydbg_connect.html" />
    
    
    <link rel="prev" href="15-tinydbg_core1.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../../">
            
                <a href="../../">
            
                    
                    1 Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../../2-preface/">
            
                <a href="../../2-preface/">
            
                    
                    2 Preface
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="../../3-terms/">
            
                <a href="../../3-terms/">
            
                    
                    3 Common Terms
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="../../4-basics/">
            
                <a href="../../4-basics/">
            
                    
                    4 Software Debugging Basics
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="../../4-basics/1-purposes.html">
            
                <a href="../../4-basics/1-purposes.html">
            
                    
                    4.1 Debugging Purposes
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2" data-path="../../4-basics/2-dependencies.html">
            
                <a href="../../4-basics/2-dependencies.html">
            
                    
                    4.2 Debugging Dependencies
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3" data-path="../../4-basics/3-countertactics.html">
            
                <a href="../../4-basics/3-countertactics.html">
            
                    
                    4.3 Anti-Debugging Techniques
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="../../5-debugger-skeleton/">
            
                <a href="../../5-debugger-skeleton/">
            
                    
                    5 Entering Debugger Development
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.5.1" data-path="../../5-debugger-skeleton/1-debugger_skeleton.html">
            
                <a href="../../5-debugger-skeleton/1-debugger_skeleton.html">
            
                    
                    5.1 Debugger Overview
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5.2" data-path="../../5-debugger-skeleton/2-debugger_demo.html">
            
                <a href="../../5-debugger-skeleton/2-debugger_demo.html">
            
                    
                    5.2 Debugger Example
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="../../6-develop-inst-debugger/">
            
                <a href="../../6-develop-inst-debugger/">
            
                    
                    6 Developing Go Instruction-Level Debugger
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.6.1" data-path="../../6-develop-inst-debugger/1-process_start.html">
            
                <a href="../../6-develop-inst-debugger/1-process_start.html">
            
                    
                    6.1 Process Launch
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.2" data-path="../../6-develop-inst-debugger/2-process_attach.html">
            
                <a href="../../6-develop-inst-debugger/2-process_attach.html">
            
                    
                    6.2 Process Attach
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.3" data-path="../../6-develop-inst-debugger/3-process_start_attach.html">
            
                <a href="../../6-develop-inst-debugger/3-process_start_attach.html">
            
                    
                    6.3 Launch & Attach
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.4" data-path="../../6-develop-inst-debugger/4-debug-session.html">
            
                <a href="../../6-develop-inst-debugger/4-debug-session.html">
            
                    
                    6.4 Debug Session
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.5" data-path="../../6-develop-inst-debugger/5-disassemble.html">
            
                <a href="../../6-develop-inst-debugger/5-disassemble.html">
            
                    
                    6.5 Disassembly
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.6" data-path="../../6-develop-inst-debugger/6-breakpoint.html">
            
                <a href="../../6-develop-inst-debugger/6-breakpoint.html">
            
                    
                    6.6 Adding Breakpoints
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.7" data-path="../../6-develop-inst-debugger/7-breakpoints.html">
            
                <a href="../../6-develop-inst-debugger/7-breakpoints.html">
            
                    
                    6.7 Listing Breakpoints
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.8" data-path="../../6-develop-inst-debugger/8-clear.html">
            
                <a href="../../6-develop-inst-debugger/8-clear.html">
            
                    
                    6.8 Removing Breakpoints
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.9" data-path="../../6-develop-inst-debugger/9-clearall.html">
            
                <a href="../../6-develop-inst-debugger/9-clearall.html">
            
                    
                    6.9 Clearing All Breakpoints
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.10" data-path="../../6-develop-inst-debugger/10-step.html">
            
                <a href="../../6-develop-inst-debugger/10-step.html">
            
                    
                    6.10 Stepping Operations
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.11" data-path="../../6-develop-inst-debugger/11-continue.html">
            
                <a href="../../6-develop-inst-debugger/11-continue.html">
            
                    
                    6.11 Running to Breakpoint
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.12" data-path="../../6-develop-inst-debugger/12-pmem.html">
            
                <a href="../../6-develop-inst-debugger/12-pmem.html">
            
                    
                    6.12 Printing Memory Data
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.13" data-path="../../6-develop-inst-debugger/13-pregs.html">
            
                <a href="../../6-develop-inst-debugger/13-pregs.html">
            
                    
                    6.13 Printing Register Data
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.14" data-path="../../6-develop-inst-debugger/14-set-mem.html">
            
                <a href="../../6-develop-inst-debugger/14-set-mem.html">
            
                    
                    6.14 Modifying Memory Data
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.15" data-path="../../6-develop-inst-debugger/15-set-regs.html">
            
                <a href="../../6-develop-inst-debugger/15-set-regs.html">
            
                    
                    6.15 Modifying Register Data
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.16" data-path="../../6-develop-inst-debugger/20-trace_new_threads.html">
            
                <a href="../../6-develop-inst-debugger/20-trace_new_threads.html">
            
                    
                    6.20 Tracing Multi-threaded Programs 1
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.17" data-path="../../6-develop-inst-debugger/21-trace_old_threads.html">
            
                <a href="../../6-develop-inst-debugger/21-trace_old_threads.html">
            
                    
                    6.21 Tracing Multi-threaded Programs 2
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.18" data-path="../../6-develop-inst-debugger/80-aslr.html">
            
                <a href="../../6-develop-inst-debugger/80-aslr.html">
            
                    
                    6.80 Understanding ASLR
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6.19" data-path="../../6-develop-inst-debugger/99-more.html">
            
                <a href="../../6-develop-inst-debugger/99-more.html">
            
                    
                    6.99 More...
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="../../7-headto-sym-debugger/">
            
                <a href="../../7-headto-sym-debugger/">
            
                    
                    7 Advancing to Symbol-Level Debugger
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.1" data-path="../../7-headto-sym-debugger/1-how-go-build-works.html">
            
                <a href="../../7-headto-sym-debugger/1-how-go-build-works.html">
            
                    
                    7.1 Go Build Internals
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.2" data-path="../../7-headto-sym-debugger/2-elf.html">
            
                <a href="../../7-headto-sym-debugger/2-elf.html">
            
                    
                    7.2 Understanding ELF Files
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.3" data-path="../../7-headto-sym-debugger/3-syms.html">
            
                <a href="../../7-headto-sym-debugger/3-syms.html">
            
                    
                    7.3 Symbols & Symbol Tables
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.4" data-path="../../7-headto-sym-debugger/4-syms-resolve-reloc.html">
            
                <a href="../../7-headto-sym-debugger/4-syms-resolve-reloc.html">
            
                    
                    7.4 Symbol Resolution & Relocation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.5" data-path="../../7-headto-sym-debugger/5-loading.html">
            
                <a href="../../7-headto-sym-debugger/5-loading.html">
            
                    
                    7.5 Loading
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.6" data-path="../../7-headto-sym-debugger/6-gopkg-debug/">
            
                <a href="../../7-headto-sym-debugger/6-gopkg-debug/">
            
                    
                    7.6 Go Standard Library debug/*
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.6.1" data-path="../../7-headto-sym-debugger/6-gopkg-debug/1-elf.html">
            
                <a href="../../7-headto-sym-debugger/6-gopkg-debug/1-elf.html">
            
                    
                    7.6.1 debug/elf
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.6.2" data-path="../../7-headto-sym-debugger/6-gopkg-debug/2-gosym.html">
            
                <a href="../../7-headto-sym-debugger/6-gopkg-debug/2-gosym.html">
            
                    
                    7.6.2 debug/gosym
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.6.3" data-path="../../7-headto-sym-debugger/6-gopkg-debug/3-dwarf.html">
            
                <a href="../../7-headto-sym-debugger/6-gopkg-debug/3-dwarf.html">
            
                    
                    7.6.3 debug/dwarf
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.7.7" data-path="../../7-headto-sym-debugger/7-headto-dwarf/">
            
                <a href="../../7-headto-sym-debugger/7-headto-dwarf/">
            
                    
                    7.7 Advancing to DWARF
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.7.1" data-path="../../7-headto-sym-debugger/7-headto-dwarf/1-gopkgs-about-dwarf.html">
            
                <a href="../../7-headto-sym-debugger/7-headto-dwarf/1-gopkgs-about-dwarf.html">
            
                    
                    7.7.1 Related Go Packages
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.7.2" data-path="../../7-headto-sym-debugger/7-headto-dwarf/2-delve-into-internals.html">
            
                <a href="../../7-headto-sym-debugger/7-headto-dwarf/2-delve-into-internals.html">
            
                    
                    7.7.2 How to Crack Those Details
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.7.3" data-path="../../7-headto-sym-debugger/7-headto-dwarf/3-compiler-gen-dwarfdata.html">
            
                <a href="../../7-headto-sym-debugger/7-headto-dwarf/3-compiler-gen-dwarfdata.html">
            
                    
                    7.7.3 Compiler Generated DWARF Data
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.7.4" data-path="../../7-headto-sym-debugger/7-headto-dwarf/4-linker-gen-dwarfdata.html">
            
                <a href="../../7-headto-sym-debugger/7-headto-dwarf/4-linker-gen-dwarfdata.html">
            
                    
                    7.7.4 Linker Generated DWARF Data
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.7.5" data-path="../../7-headto-sym-debugger/7-headto-dwarf/5-headto-dwarf.html">
            
                <a href="../../7-headto-sym-debugger/7-headto-dwarf/5-headto-dwarf.html">
            
                    
                    7.7.5 Understanding DWARF
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="../../8-dwarf/">
            
                <a href="../../8-dwarf/">
            
                    
                    8 Debug Information Standard: DWARF
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.8.1" data-path="../../8-dwarf/1-history.html">
            
                <a href="../../8-dwarf/1-history.html">
            
                    
                    8.1 DWARF Development History
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.2" data-path="../../8-dwarf/2-overview.html">
            
                <a href="../../8-dwarf/2-overview.html">
            
                    
                    8.2 DWARF Content Overview
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.3" data-path="../../8-dwarf/3-dwarfdata.html">
            
                <a href="../../8-dwarf/3-dwarfdata.html">
            
                    
                    8.3 DWARF Data Classification
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.4" data-path="../../8-dwarf/4-die/">
            
                <a href="../../8-dwarf/4-die/">
            
                    
                    8.4 DIE Detailed Introduction
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.8.4.1" data-path="../../8-dwarf/4-die/1-desc-data-type.html">
            
                <a href="../../8-dwarf/4-die/1-desc-data-type.html">
            
                    
                    8.4.1 DIE Describing Data and Types
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.4.2" data-path="../../8-dwarf/4-die/2-desc-locations.html">
            
                <a href="../../8-dwarf/4-die/2-desc-locations.html">
            
                    
                    8.4.2 Location Data
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.4.3" data-path="../../8-dwarf/4-die/3-desc-code.html">
            
                <a href="../../8-dwarf/4-die/3-desc-code.html">
            
                    
                    8.4.3 DIE Describing Executable Code
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.4.4" data-path="../../8-dwarf/4-die/4-encoding.html">
            
                <a href="../../8-dwarf/4-die/4-encoding.html">
            
                    
                    8.4.4 DIE Data Encoding
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.8.5" data-path="../../8-dwarf/5-other/">
            
                <a href="../../8-dwarf/5-other/">
            
                    
                    8.5 Other Debug Data
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.8.5.1" data-path="../../8-dwarf/5-other/1-accelerated-access.html">
            
                <a href="../../8-dwarf/5-other/1-accelerated-access.html">
            
                    
                    8.5.1 Accelerated Access
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.5.2" data-path="../../8-dwarf/5-other/2-lineno-table.html">
            
                <a href="../../8-dwarf/5-other/2-lineno-table.html">
            
                    
                    8.5.2 Line Number Table Information
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.5.3" data-path="../../8-dwarf/5-other/3-callframe-info.html">
            
                <a href="../../8-dwarf/5-other/3-callframe-info.html">
            
                    
                    8.5.3 Call Frame Information
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.5.4" data-path="../../8-dwarf/5-other/4-macro-info.html">
            
                <a href="../../8-dwarf/5-other/4-macro-info.html">
            
                    
                    8.5.4 Macro Information
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.5.5" data-path="../../8-dwarf/5-other/5-varlen-data.html">
            
                <a href="../../8-dwarf/5-other/5-varlen-data.html">
            
                    
                    8.5.5 Variable Length Data
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.5.6" data-path="../../8-dwarf/5-other/6-shrink-data.html">
            
                <a href="../../8-dwarf/5-other/6-shrink-data.html">
            
                    
                    8.5.6 Compressed DWARF Data
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.5.7" data-path="../../8-dwarf/5-other/7-elf-sections.html">
            
                <a href="../../8-dwarf/5-other/7-elf-sections.html">
            
                    
                    8.5.7 ELF Sections
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.8.6" data-path="../../8-dwarf/6-practices.html">
            
                <a href="../../8-dwarf/6-practices.html">
            
                    
                    8.6 DWARF Parsing and Applications
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.8.7" data-path="../../8-dwarf/7-summary.html">
            
                <a href="../../8-dwarf/7-summary.html">
            
                    
                    8.7 Summary
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="../">
            
                <a href="../">
            
                    
                    9 Developing Go Symbol-Level Debugger
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.9.1" data-path="../1-æ¶æè®¾è®¡/">
            
                <a href="../1-æ¶æè®¾è®¡/">
            
                    
                    9.1 Architecture Design
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.9.1.1" data-path="../1-æ¶æè®¾è®¡/1-ç°ä»£è°è¯å¨æ¶æ.html">
            
                <a href="../1-æ¶æè®¾è®¡/1-ç°ä»£è°è¯å¨æ¶æ.html">
            
                    
                    9.1.1 Modern Debugger Architecture
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.1.2" data-path="../1-æ¶æè®¾è®¡/2-åç«¯UIå±è®¾è®¡.html">
            
                <a href="../1-æ¶æè®¾è®¡/2-åç«¯UIå±è®¾è®¡.html">
            
                    
                    9.1.2 Frontend UI Layer Design
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.1.3" data-path="../1-æ¶æè®¾è®¡/3-Serviceå±è®¾è®¡.html">
            
                <a href="../1-æ¶æè®¾è®¡/3-Serviceå±è®¾è®¡.html">
            
                    
                    9.1.3 Service Layer Design
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.1.4" data-path="../1-æ¶æè®¾è®¡/4-åç«¯ç¬¦å·å±è®¾è®¡.html">
            
                <a href="../1-æ¶æè®¾è®¡/4-åç«¯ç¬¦å·å±è®¾è®¡.html">
            
                    
                    9.1.4 Backend Symbol Layer Design
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.1.5" data-path="../1-æ¶æè®¾è®¡/5-åç«¯ç®æ å±è®¾è®¡.html">
            
                <a href="../1-æ¶æè®¾è®¡/5-åç«¯ç®æ å±è®¾è®¡.html">
            
                    
                    9.1.5 Backend Target Layer Design
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.1.6" data-path="../1-æ¶æè®¾è®¡/6-æ¥å¿ç³»ç»è®¾è®¡.html">
            
                <a href="../1-æ¶æè®¾è®¡/6-æ¥å¿ç³»ç»è®¾è®¡.html">
            
                    
                    9.1.6 Logging System Design
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.9.2" data-path="./">
            
                <a href="./">
            
                    
                    9.2 Core Debugging Logic
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.9.2.1" data-path="00-cmds.html">
            
                <a href="00-cmds.html">
            
                    
                    9.2.00 Core Debugging Commands
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2.2" data-path="01-debug-session.html">
            
                <a href="01-debug-session.html">
            
                    
                    9.2.01 Opening Debug Session
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2.3" data-path="11-tinydbg_attach.html">
            
                <a href="11-tinydbg_attach.html">
            
                    
                    9.2.11 tinydbg attach
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2.4" data-path="12-tinydbg_attach_waitfor.html">
            
                <a href="12-tinydbg_attach_waitfor.html">
            
                    
                    9.2.12 tinydbg attach+waitfor
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2.5" data-path="13-tinydbg_exec.html">
            
                <a href="13-tinydbg_exec.html">
            
                    
                    9.2.13 tinydbg exec
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2.6" data-path="14-tinydbg_debug.html">
            
                <a href="14-tinydbg_debug.html">
            
                    
                    9.2.14 tinydbg debug
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2.7" data-path="15-tinydbg_core1.html">
            
                <a href="15-tinydbg_core1.html">
            
                    
                    9.2.15 tinydbg core - part1
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.9.2.8" data-path="15-tinydbg_core2.html">
            
                <a href="15-tinydbg_core2.html">
            
                    
                    9.2.15 tinydbg core - part2
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2.9" data-path="16-tinydbg_connect.html">
            
                <a href="16-tinydbg_connect.html">
            
                    
                    9.2.16 tinydbg connect
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2.10" data-path="17-tinydbg_trace.html">
            
                <a href="17-tinydbg_trace.html">
            
                    
                    9.2.17 tinydbg trace
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2.11" data-path="21-disassemble.html">
            
                <a href="21-disassemble.html">
            
                    
                    9.2.21 tinydbg> disass
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2.12" data-path="22-breakpoint.html">
            
                <a href="22-breakpoint.html">
            
                    
                    9.2.22 tinydbg> breakpoint
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2.13" data-path="23-breakpoints.html">
            
                <a href="23-breakpoints.html">
            
                    
                    9.2.23 tinydbg> breakpoints
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2.14" data-path="24-clear.html">
            
                <a href="24-clear.html">
            
                    
                    9.2.24 tinydbg> clear | toggle
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2.15" data-path="25-clearall.html">
            
                <a href="25-clearall.html">
            
                    
                    9.2.25 tinydbg> clearall
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2.16" data-path="26-step.html">
            
                <a href="26-step.html">
            
                    
                    9.2.26 tinydbg> next | step | stepi
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2.17" data-path="27-continue.html">
            
                <a href="27-continue.html">
            
                    
                    9.2.27 Continue Execution
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2.18" data-path="28-pmem.html">
            
                <a href="28-pmem.html">
            
                    
                    9.2.28 View Memory
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2.19" data-path="29-regs.html">
            
                <a href="29-regs.html">
            
                    
                    9.2.29 View Registers
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2.20" data-path="30-call-frame.html">
            
                <a href="30-call-frame.html">
            
                    
                    9.2.30 Call Frame Information
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2.21" data-path="31-vars.html">
            
                <a href="31-vars.html">
            
                    
                    9.2.31 Variables & Type System
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2.22" data-path="32-how_listfunctions_work.html">
            
                <a href="32-how_listfunctions_work.html">
            
                    
                    9.2.32 how ListFunctions work
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2.23" data-path="32-funcs.html">
            
                <a href="32-funcs.html">
            
                    
                    9.2.32 funcs
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2.24" data-path="33-goroutines.html">
            
                <a href="33-goroutines.html">
            
                    
                    9.2.33 Goroutines
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2.25" data-path="34-multi-threads.html">
            
                <a href="34-multi-threads.html">
            
                    
                    9.2.34 Tracing Multi-threaded Programs
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.9.3" data-path="../3-é«çº§åè½æ©å±/">
            
                <a href="../3-é«çº§åè½æ©å±/">
            
                    
                    9.3 Advanced Feature Extensions
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.9.3.1" data-path="../3-é«çº§åè½æ©å±/100-howto_integrate_starlark.html">
            
                <a href="../3-é«çº§åè½æ©å±/100-howto_integrate_starlark.html">
            
                    
                    9.3.100 Integrating starlark
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.3.2" data-path="../3-é«çº§åè½æ©å±/101-howto_tracing_via_ebpf.html">
            
                <a href="../3-é«çº§åè½æ©å±/101-howto_tracing_via_ebpf.html">
            
                    
                    9.3.101 Tracing with eBPF
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.3.3" data-path="../3-é«çº§åè½æ©å±/102-howto_syntax_highlight.html">
            
                <a href="../3-é«çº§åè½æ©å±/102-howto_syntax_highlight.html">
            
                    
                    9.3.102 Implementing Syntax Highlighting
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.3.4" data-path="../3-é«çº§åè½æ©å±/103-howto_paging_output.html">
            
                <a href="../3-é«çº§åè½æ©å±/103-howto_paging_output.html">
            
                    
                    9.3.103 Implementing Paged Output
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.3.5" data-path="../3-é«çº§åè½æ©å±/104-howto_read_separate_dwarfdata.html">
            
                <a href="../3-é«çº§åè½æ©å±/104-howto_read_separate_dwarfdata.html">
            
                    
                    9.3.104 Reading Separately Stored DWARF Data
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.3.6" data-path="../3-é«çº§åè½æ©å±/105-howto_guess_substitutepath.html">
            
                <a href="../3-é«çº§åè½æ©å±/105-howto_guess_substitutepath.html">
            
                    
                    9.3.105 Automatic Source File Path Mapping
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.3.7" data-path="../3-é«çº§åè½æ©å±/106-howto_redirect_target_io.html">
            
                <a href="../3-é«çº§åè½æ©å±/106-howto_redirect_target_io.html">
            
                    
                    9.3.106 Implementing Target Process IO Redirection
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.3.8" data-path="../3-é«çº§åè½æ©å±/107-howto_customize_tinydbg.html">
            
                <a href="../3-é«çº§åè½æ©å±/107-howto_customize_tinydbg.html">
            
                    
                    9.3.107 Supporting User Preferences
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.3.9" data-path="../3-é«çº§åè½æ©å±/108-howto_accept_multiclient.html">
            
                <a href="../3-é«çº§åè½æ©å±/108-howto_accept_multiclient.html">
            
                    
                    9.3.108 Supporting Multi-client Debug Mode
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.3.10" data-path="../3-é«çº§åè½æ©å±/109-howto_transcript_debugging.html">
            
                <a href="../3-é«çº§åè½æ©å±/109-howto_transcript_debugging.html">
            
                    
                    9.3.109 Supporting Debug Activity Logging
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="../../10-extras/">
            
                <a href="../../10-extras/">
            
                    
                    10 Mainstream Debugging Technology Analysis
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.10.1" data-path="../../10-extras/1-development-of-debugger.html">
            
                <a href="../../10-extras/1-development-of-debugger.html">
            
                    
                    10.1 Debugger Development History
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.2" data-path="../../10-extras/2-development-of-logging.html">
            
                <a href="../../10-extras/2-development-of-logging.html">
            
                    
                    10.2 Logging System Development History
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.3" data-path="../../10-extras/3-development-of-metrics.html">
            
                <a href="../../10-extras/3-development-of-metrics.html">
            
                    
                    10.3 Metrics System Development History
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.4" data-path="../../10-extras/4-development-of-tracing.html">
            
                <a href="../../10-extras/4-development-of-tracing.html">
            
                    
                    10.4 Tracing System Development History
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.5" data-path="../../10-extras/5-development-of-bisect.html">
            
                <a href="../../10-extras/5-development-of-bisect.html">
            
                    
                    10.5 Bisect Development History
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.6" data-path="../../10-extras/6-development-of-ebpf.html">
            
                <a href="../../10-extras/6-development-of-ebpf.html">
            
                    
                    10.6 eBPF Development History
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.7" data-path="../../10-extras/7-development-of-replay.html">
            
                <a href="../../10-extras/7-development-of-replay.html">
            
                    
                    10.7 Record and Replay Development History
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.10.8" data-path="../../10-extras/8-development-of-debug-dsys.html">
            
                <a href="../../10-extras/8-development-of-debug-dsys.html">
            
                    
                    10.8 Distributed Debugging Development History
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.11" data-path="../../11-thanks/">
            
                <a href="../../11-thanks/">
            
                    
                    11 Acknowledgments
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12" data-path="../../12-appendix/">
            
                <a href="../../12-appendix/">
            
                    
                    12 Appendix
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.12.1" data-path="../../12-appendix/1-go-programme-start.html">
            
                <a href="../../12-appendix/1-go-programme-start.html">
            
                    
                    12.1 Go Program Startup Process
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.2" data-path="../../12-appendix/2-auto-trace-cloned-threads.html">
            
                <a href="../../12-appendix/2-auto-trace-cloned-threads.html">
            
                    
                    12.2 Automatic Thread Tracing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.3" data-path="../../12-appendix/3-git-bisect.html">
            
                <a href="../../12-appendix/3-git-bisect.html">
            
                    
                    12.3 git bisect
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.4" data-path="../../12-appendix/80-go-tool-compile.html">
            
                <a href="../../12-appendix/80-go-tool-compile.html">
            
                    
                    12.10 Compilation Toolchain/compile
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.5" data-path="../../12-appendix/81-go-tool-asm.html">
            
                <a href="../../12-appendix/81-go-tool-asm.html">
            
                    
                    12.11 Compilation Toolchain/asm
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.6" data-path="../../12-appendix/82-go-tool-link.html">
            
                <a href="../../12-appendix/82-go-tool-link.html">
            
                    
                    12.12 Compilation Toolchain/link
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.7" data-path="../../12-appendix/90-why-buildid-loaded.html">
            
                <a href="../../12-appendix/90-why-buildid-loaded.html">
            
                    
                    12.13 More: GNU build-id+gobuildid
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.8" data-path="../../12-appendix/91-syntax-and-semantic-analysis.html">
            
                <a href="../../12-appendix/91-syntax-and-semantic-analysis.html">
            
                    
                    12.14 More: Syntax Analysis vs Semantic Analysis
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.12.9" data-path="../../12-appendix/92-why-gdb-uses-symtab.html">
            
                <a href="../../12-appendix/92-why-gdb-uses-symtab.html">
            
                    
                    12.15 More: Why GDB Uses Symbol Table+DWARF
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="../.." >9.2.15 tinydbg core - part2</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h2 id="core-part2-generating-core--debugging-core">Core (Part2): Generating Core + Debugging Core</h2>
<h3 id="implementation-goal-tinydbg-core-corefile">Implementation Goal: <code>tinydbg core [corefile]</code></h3>
<p>In this section, we introduce debugging based on core files using <code>tinydbg core [corefile]</code>. Typically, a core file is a memory snapshot generated by the operating system when a program terminates abnormally or crashes. It contains information about the program&apos;s state at the time of crash, which the debugger can use to reconstruct the execution context and help developers locate issues.</p>
<p>One of the most common operations when using core files for problem diagnosis is executing the <code>bt</code> command to locate the program&apos;s stack at the time of crash. This is particularly useful for identifying SEGMENTATION FAULT issues. Most mainstream programming languages now provide stack trace capabilities when exceptions or serious errors occur, making it easier for developers to examine the problem stack.</p>
<p>For example:</p>
<ol>
<li>Go language supports both panic recovery and stack trace printing through debug.Stack(); setting GOTRACKBACK=crash environment variable can generate core files on crashes;</li>
<li>Java language can print current thread stack information through Thread.dumpStack() or Throwable.printStackTrace(); JVM generates hs_err_pid*.log files to record crash information;</li>
<li>C++ can obtain stack information through functions like backtrace() and backtrace_symbols(); core dumps can be enabled by setting ulimit -c unlimited, generating core files on program crashes;</li>
</ol>
<p>Core files are essentially snapshots of a process at a particular moment, and they don&apos;t necessarily have to be generated only during crashes. For example, <code>gcore &lt;pid&gt;</code> can generate a core file without terminating the process. Of course, this is typically done when trying to diagnose process issues, and for online services, traffic should be diverted before doing this since the process is paused during core file generation.</p>
<h3 id="basic-knowledge">Basic Knowledge</h3>
<h4 id="what-information-does-core-contain">What Information Does Core Contain</h4>
<p>Part 1 provided a detailed introduction to core files, but let&apos;s briefly review here. A core file is a memory snapshot of a process that contains the program&apos;s memory content and register state at the time of crash. It mainly consists of the following parts:</p>
<ol>
<li>ELF Header Information: Identifies this as a core file, containing basic information like file type and machine architecture</li>
<li>Program Header Table: Describes the location and attributes of various segments in the core file</li>
<li>Memory Mapping Segments:<ul>
<li>Contains program code segments, data segments, heap, stack, and other memory regions</li>
<li>Each segment has corresponding virtual address and access permission information</li>
</ul>
</li>
<li>Register State:<ul>
<li>General register values for all threads</li>
<li>Floating-point register state</li>
<li>Special register state</li>
</ul>
</li>
<li>Other Information:<ul>
<li>Process information like process ID, user ID</li>
<li>Signal information that caused the crash</li>
<li>Command line arguments and environment variables</li>
<li>Open file descriptor information</li>
</ul>
</li>
</ol>
<p>The debugger can read this information from the core file to reconstruct the program&apos;s execution context at the time of crash, helping developers perform post-mortem debugging analysis and problem review.</p>
<h4 id="how-core-files-are-generated">How Core Files Are Generated</h4>
<h3 id="core-file-generation-in-linux">Core File Generation in Linux</h3>
<h4 id="generated-by-linux-kernel">Generated by Linux Kernel</h4>
<p>When a program receives certain specific signals (such as SIGSEGV, SIGABRT, etc.), if the system has core dump functionality enabled, the kernel will help generate a core file. The specific process is as follows:</p>
<ol>
<li><p>Common signals that trigger core dumps:</p>
<ul>
<li>SIGSEGV: Segmentation fault, illegal memory access</li>
<li>SIGABRT: Called abort() function</li>
<li>SIGFPE: Floating point exception</li>
<li>SIGILL: Illegal instruction</li>
<li>SIGBUS: Bus error</li>
<li>SIGQUIT: User sent quit signal</li>
</ul>
</li>
<li><p>System Configuration:</p>
<pre><code class="lang-bash"><span class="hljs-comment"># Check if core dump is enabled</span>
<span class="hljs-built_in">ulimit</span> -c

<span class="hljs-comment"># Set core file size limit (unlimited means no limit)</span>
<span class="hljs-built_in">ulimit</span> -c unlimited

<span class="hljs-comment"># Configure core file path format</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;/tmp/core-%e-%p-%t&quot;</span> &gt; /proc/sys/kernel/core_pattern
</code></pre>
</li>
<li><p>Kernel Processing Flow:</p>
<ol>
<li>When the process receives the above signals, the kernel intervenes</li>
<li>Checks if system core dump configuration allows core file generation</li>
<li>Kernel pauses all threads of the process</li>
<li>Collects process memory mappings, register states, and other information</li>
<li>Writes information to core file</li>
<li>Terminates the process</li>
</ol>
</li>
<li><p>Core File Naming Rules (/proc/sys/kernel/core_pattern):</p>
<ul>
<li>%p - Process ID</li>
<li>%u - User ID</li>
<li>%g - Group ID</li>
<li>%s - Signal number that caused core dump</li>
<li>%t - Core dump time (UNIX timestamp)</li>
<li>%h - Hostname</li>
<li>%e - Executable filename</li>
</ul>
</li>
</ol>
<p>So generating core files doesn&apos;t require debugger participation - this is an important feature provided by the Linux kernel. The debugger&apos;s role is to analyze this core file afterward, reconstructing the crash scene for debugging.</p>
<h4 id="generated-by-custom-tools">Generated by Custom Tools</h4>
<p>Besides the above methods of sending signals to processes and utilizing the kernel&apos;s capabilities to automatically generate core files, our custom debugging tools can also implement core file dumping capabilities.</p>
<p>For example, gcore in the gdb software package can also generate core files for processes without actually terminating them. Although most of the time core files are generated for online services when they encounter serious errors, we can actually generate core files without killing the process, and the implementation is not complicated.</p>
<p>For example, if we want to generate a core file for a certain process, we can do this:</p>
<ul>
<li>Use the <code>ptrace</code> system call to attach to the target process;</li>
<li>Read <code>/proc/&lt;pid&gt;/maps</code> to understand memory layout;</li>
<li>Use <code>process_vm_readv()</code> or <code>ptrace(PTRACE_PEEKDATA, ...)</code> to read memory regions;</li>
<li>Use <code>ptrace(PTRACE_GETREGS, ...)</code> to capture register state;</li>
<li>Get open files, thread information, etc.;</li>
<li>Get startup environment variables, startup parameters, build parameters, etc.;</li>
<li>...</li>
<li>Organize the above information of interest into the core file format and write it.</li>
</ul>
<p>OK, let&apos;s see how tinydbg generates core files and loads core files.</p>
<h3 id="code-implementation">Code Implementation</h3>
<p>Core file generation is actually implemented through the debug session command <code>tinydbg&gt; dump &lt;corefile&gt;</code>, while loading core files and starting debugging is implemented through <code>tinydbg core &lt;executable&gt; &lt;corefile&gt;</code>. According to our directory arrangement, in this section we should first introduce the core command, then the debug session commands, and finally the dump command. However, the production and consumption of core file data are closely related, and having production and consumption separated by many chapters would make it difficult for readers to understand and learn.</p>
<p>Therefore, we&apos;ll first introduce how the dump command implements core file generation, and then discuss core file consumption.</p>
<h4 id="tinydbg-generating-core-files">tinydbg Generating Core Files</h4>
<pre><code class="lang-bash">$ (tinydbg) <span class="hljs-built_in">help</span> dump
Creates a core dump from the current process state

        dump &lt;output file&gt;

The core dump is always written <span class="hljs-keyword">in</span> ELF, even on systems (windows, macOS) <span class="hljs-built_in">where</span> this is not customary. For environments other than linux/amd64 threads and registers are dumped <span class="hljs-keyword">in</span> a format that only Delve can <span class="hljs-built_in">read</span> back.
</code></pre>
<p>Core code path for generating core files:</p>
<pre><code class="lang-bash">debug_other.go:debugCmd.cmdFn(...)
    \--&gt; dump(s *Session, ctx callContext, args string)
            \--&gt; dumpState, err := t.client.CoreDumpStart(args)
                    \--&gt; c.call(<span class="hljs-string">&quot;DumpStart&quot;</span>, DumpStartIn{Destination: dest}, out)
            \--&gt; forloop
                    \--&gt; <span class="hljs-built_in">print</span> dumping progress
                    \--&gt; <span class="hljs-keyword">if</span> !dumpState.Dumping { <span class="hljs-built_in">break</span> }
                    \--&gt; <span class="hljs-keyword">else</span> { 
                            dumpState = t.client.CoreDumpWait(1000)}
                                \--&gt; c.call(<span class="hljs-string">&quot;DumpWait&quot;</span>, DumpWaitIn{Wait: msec}, out)
                         }
</code></pre>
<p>For the debugger backend, the code path is:</p>
<pre><code class="lang-bash">tinydbg/service/rpc2.(*RPCServer).DumpStart(arg DumpStartIn, out *DumpStartOut)
    \--&gt; s.debugger.DumpStart(arg.Destination)
            \--&gt; (d *Debugger) DumpStart(dest string) error {
                    \--&gt; (t *Target) Dump(out elfwriter.WriteCloserSeeker, flags DumpFlags, state *DumpState) 
                            \--&gt; 1. dump os/machine/abi... info as file header
                            \--&gt; 2. t.dumpMemory(state, w, mme): write mapped memory data
                                    \--&gt; update DumpState.MemoryDone, DumpState.MemoryTotal
                            \--&gt; 3. prepare notes of dlv header, process, threads and other info
                                    \--&gt; prepare note of dlv header: ... 
                                    \--&gt; prepare note of process: t.proc.DumpProcessNotes(notes, state.threadDone)
                                    \--&gt; <span class="hljs-keyword">for</span> each thread:
                                            \--&gt; t.dumpThreadNotes(notes, state, th)
                                            \--&gt; update DumpState.ThreadsDone, DumpState.ThreadsTotal
                            \--&gt; 4. w.WriteNotes(notes): dump dlv header, process info, threads info, and others as 
                                    a new PT_NOTE <span class="hljs-built_in">type</span> entry of ProgHeader table 
    \--&gt; out.State = *api.ConvertDumpState(s.debugger.DumpWait(0))
    \--&gt; <span class="hljs-built_in">return</span> DumpState to rpc2.Client
</code></pre>
<p>Looking at the specific source code implementation, it&apos;s clear that the process dumping might take some time and won&apos;t complete immediately. So after the client requests DumpStart, the server will first return a DumpState, which is the current state and may not be completely finished. If not finished, the client will request <code>dumpState := t.client.CoreDumpWait(...)</code> again every 1 second to get the dumping progress.</p>
<p>After reading the Dump implementation below, you&apos;ll understand how the dumping progress is calculated - there are just two metrics: whether thread information has been completely dumped, and whether memory information has been completely dumped. These two parts might take longer depending on the process workload.</p>
<pre><code class="lang-go"><span class="hljs-comment">// DumpStart starts a core dump to arg.Destination.</span>
<span class="hljs-keyword">func</span> (s *RPCServer) DumpStart(arg DumpStartIn, out *DumpStartOut) error {
    err := s.debugger.DumpStart(arg.Destination)
    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
        <span class="hljs-keyword">return</span> err
    }
    out.State = *api.ConvertDumpState(s.debugger.DumpWait(<span class="hljs-number">0</span>))
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
}

<span class="hljs-comment">// ConvertDumpState converts proc.DumpState to api.DumpState.</span>
<span class="hljs-keyword">func</span> ConvertDumpState(dumpState *proc.DumpState) *DumpState {
    ...
    <span class="hljs-keyword">return</span> &amp;DumpState{
        Dumping:      dumpState.Dumping,
        AllDone:      dumpState.AllDone,
        ThreadsDone:  dumpState.ThreadsDone,
        ThreadsTotal: dumpState.ThreadsTotal,
        MemDone:      dumpState.MemDone,
        MemTotal:     dumpState.MemTotal,
    }
}

<span class="hljs-comment">// DumpStart starts a core dump to dest.</span>
<span class="hljs-keyword">func</span> (d *Debugger) DumpStart(dest <span class="hljs-keyword">string</span>) error {
    ...
    fh, err := os.Create(dest)
    ...
    d.dumpState.Dumping = <span class="hljs-literal">true</span>
    d.dumpState.AllDone = <span class="hljs-literal">false</span>
    d.dumpState.Canceled = <span class="hljs-literal">false</span>
    d.dumpState.DoneChan = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>{})
    d.dumpState.ThreadsDone = <span class="hljs-number">0</span>
    d.dumpState.ThreadsTotal = <span class="hljs-number">0</span>
    d.dumpState.MemDone = <span class="hljs-number">0</span>
    d.dumpState.MemTotal = <span class="hljs-number">0</span>
    d.dumpState.Err = <span class="hljs-literal">nil</span>

    <span class="hljs-keyword">go</span> d.target.Selected.Dump(fh, <span class="hljs-number">0</span>, &amp;d.dumpState)
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
}
</code></pre>
<p>Here, selected actually refers to a Target in TargetGroup, and Target refers to the process dimension. For single-process programs, there&apos;s only one Target in TargetGroup. For multi-process programs, if <code>tinydbg&gt; target follow-exec [-on [regex]] [-off]</code> is enabled in debug mode, when a child process is created and its command matches the regular expression, the newly created process will be automatically managed. In this case, TargetGroup will have more than one Target. Of course, the Target layer control backend implementation must support controlling parent-child processes. The native backend supports this, and for the gdb debugger, <code>set follow-fork-mode child</code> is also supported.</p>
<p>For multi-process debugging scenarios where you want to simultaneously pause and resume execution of parent and child processes, TargetGroup manages this uniformly, making it convenient to perform corresponding pause and resume operations.</p>
<p>ps: Regarding the extensible and replaceable backend issue: In our demo tinydbg, we only kept Delve&apos;s own native debugger implementation. We removed the implementation logic that supported gdb, lldb, mozilla rr, and other debugger backends. Note that the term backend here doesn&apos;t refer to the debugger server in a front-end/back-end separated architecture, but rather the part of the debugger server that controls the Target layer. When mixing Chinese and English, please pay attention to the specific meaning of terminology.</p>
<p>OK, let&apos;s continue looking at how Target.Dump(...) is implemented:</p>
<pre><code class="lang-go"><span class="hljs-comment">// Dump writes a core dump to out. State is updated as the core dump is written.</span>
<span class="hljs-keyword">func</span> (t *Target) Dump(out elfwriter.WriteCloserSeeker, flags DumpFlags, state *DumpState) {
    <span class="hljs-keyword">defer</span> <span class="hljs-keyword">func</span>() {
        state.Dumping = <span class="hljs-literal">false</span>
        <span class="hljs-built_in">close</span>(state.DoneChan)
        ...
    }()

    bi := t.BinInfo()

    <span class="hljs-comment">// 1. write the ELF corefile header</span>
    <span class="hljs-keyword">var</span> fhdr elf.FileHeader
    fhdr.Class = elf.ELFCLASS64
    fhdr.Data = elf.ELFDATA2LSB
    fhdr.Version = elf.EV_CURRENT
    fhdr.OSABI = elf.ELFOSABI_LINUX
    fhdr.Type = elf.ET_CORE
    fhdr.Machine = elf.EM_X86_64
    fhdr.Entry = <span class="hljs-number">0</span>
    w := elfwriter.New(out, &amp;fhdr) 
    ...

    <span class="hljs-comment">// prepare notes of dlv header, process, threads and others</span>
    notes := []elfwriter.Note{}
    <span class="hljs-comment">// - note of dlv header</span>
    entryPoint, _ := t.EntryPoint()
    notes = <span class="hljs-built_in">append</span>(notes, elfwriter.Note{
        Type: elfwriter.DelveHeaderNoteType,
        Name: <span class="hljs-string">&quot;Delve Header&quot;</span>,
        Data: []<span class="hljs-keyword">byte</span>(fmt.Sprintf(<span class="hljs-string">&quot;%s/%s\n%s\n%s%d\n%s%#x\n&quot;</span>, bi.GOOS, bi.Arch.Name, version.DelveVersion.String(), elfwriter.DelveHeaderTargetPidPrefix, t.pid, elfwriter.DelveHeaderEntryPointPrefix, entryPoint)),
    })

    <span class="hljs-comment">// - notes of threads</span>
    state.setThreadsTotal(<span class="hljs-built_in">len</span>(threads))

    <span class="hljs-comment">// note of process</span>
    <span class="hljs-keyword">var</span> threadsDone <span class="hljs-keyword">bool</span>
    <span class="hljs-keyword">if</span> flags&amp;DumpPlatformIndependent == <span class="hljs-number">0</span> {
        threadsDone, notes, _ = t.proc.DumpProcessNotes(notes, state.threadDone)
    }
    <span class="hljs-comment">// notes of threads</span>
    threads := t.ThreadList()
    <span class="hljs-keyword">if</span> !threadsDone {
        <span class="hljs-keyword">for</span> _, th := <span class="hljs-keyword">range</span> threads {
            notes = t.dumpThreadNotes(notes, state, th)
            state.threadDone()
        }
    }

    <span class="hljs-comment">// 2. write mapped memory data into corefile</span>
    memmap, _ := t.proc.MemoryMap()
    memmapFilter := <span class="hljs-built_in">make</span>([]MemoryMapEntry, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(memmap))
    memtot := <span class="hljs-keyword">uint64</span>(<span class="hljs-number">0</span>)
    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> memmap {
        <span class="hljs-keyword">if</span> mme := &amp;memmap[i]; t.shouldDumpMemory(mme) {
            memmapFilter = <span class="hljs-built_in">append</span>(memmapFilter, *mme)
            memtot += mme.Size
        }
    }
    state.setMemTotal(memtot)
    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> memmapFilter {
        mme := &amp;memmapFilter[i]
        t.dumpMemory(state, w, mme)
    }

    <span class="hljs-comment">// 3. write these notes into corefile as a new entry of </span>
    <span class="hljs-comment">// ProgHeader table, with type `PT_NOTE`.</span>
    notesProg := w.WriteNotes(notes)
    w.Progs = <span class="hljs-built_in">append</span>(w.Progs, notesProg)
    w.WriteProgramHeaders()
    <span class="hljs-keyword">if</span> w.Err != <span class="hljs-literal">nil</span> {
        state.setErr(fmt.Errorf(<span class="hljs-string">&quot;error writing to output file: %v&quot;</span>, w.Err))
    }
    state.Mutex.Lock()
    state.AllDone = <span class="hljs-literal">true</span>
    state.Mutex.Unlock()
}
</code></pre>
<h4 id="tinydbg-loading-core-files">tinydbg Loading Core Files</h4>
<p>Core code path for loading core files:</p>
<pre><code class="lang-bash">main.go:main.main
    \--&gt; cmds.New(<span class="hljs-literal">false</span>).Execute()
            \--&gt; coreCommand.Run()
                    \--&gt; coreCmd(...)
                            \--&gt; execute(0, []string{args[0]}, conf, args[1], debugger.ExecutingOther, args, buildFlags)
                                    \--&gt; server := rpccommon.NewServer(...)
                                    \--&gt; server.Run()
                                            \--&gt; debugger, _ := debugger.New(...)
                                                <span class="hljs-keyword">if</span> attach startup: debugger.Attach(...)
                                                <span class="hljs-keyword">elif</span> core startup: core.OpenCore(...)
                                                <span class="hljs-keyword">else</span> others debugger.Launch(...)
</code></pre>
<p>For tinydbg core, it uses the core.OpenCore(...) method.</p>
<pre><code class="lang-go"><span class="hljs-comment">// OpenCore will open the core file and return a *proc.TargetGroup.</span>
<span class="hljs-comment">// If the DWARF information cannot be found in the binary, Delve will look</span>
<span class="hljs-comment">// for external debug files in the directories passed in.</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// note: we remove the support of reading separate dwarfdata.</span>
<span class="hljs-keyword">func</span> OpenCore(corePath, exePath <span class="hljs-keyword">string</span>) (*proc.TargetGroup, error) {
    p, currentThread, err := readLinuxOrPlatformIndependentCore(corePath, exePath)
    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err
    }

    <span class="hljs-keyword">if</span> currentThread == <span class="hljs-literal">nil</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, ErrNoThreads
    }

    grp, addTarget := proc.NewGroup(p, proc.NewTargetGroupConfig{
        DisableAsyncPreempt: <span class="hljs-literal">false</span>,
        CanDump:             <span class="hljs-literal">false</span>,
    })
    _, err = addTarget(p, p.pid, currentThread, exePath, proc.StopAttached, <span class="hljs-string">&quot;&quot;</span>)
    <span class="hljs-keyword">return</span> grp, err
}
</code></pre>
<p>The core logic for reading the core file and reconstructing the problem scene is here:</p>
<pre><code class="lang-go"><span class="hljs-comment">// readLinuxOrPlatformIndependentCore reads a core file from corePath</span>
<span class="hljs-comment">// corresponding to the executable at exePath. For details on the Linux ELF</span>
<span class="hljs-comment">// core format, see:</span>
<span class="hljs-comment">// https://www.gabriel.urdhr.fr/2015/05/29/core-file/,</span>
<span class="hljs-comment">// https://uhlo.blogspot.com/2012/05/brief-look-into-core-dumps.html,</span>
<span class="hljs-comment">// elf_core_dump in https://elixir.bootlin.com/linux/v4.20.17/source/fs/binfmt_elf.c,</span>
<span class="hljs-comment">// and, if absolutely desperate, readelf.c from the binutils source.</span>
<span class="hljs-keyword">func</span> readLinuxOrPlatformIndependentCore(corePath, exePath <span class="hljs-keyword">string</span>) (*process, proc.Thread, error) {

    <span class="hljs-comment">// read notes</span>
    coreFile, _ := elf.Open(corePath)
    machineType := coreFile.Machine
    notes, platformIndependentDelveCore, err := readNotes(coreFile, machineType)
    ...

    <span class="hljs-comment">// read executable</span>
    exe, _ := os.Open(exePath)
    exeELF, _ := elf.NewFile(exe)
    ...

    <span class="hljs-comment">// 1. build memory</span>
    memory := buildMemory(coreFile, exeELF, exe, notes)

    <span class="hljs-comment">// 2. build process</span>
    bi := proc.NewBinaryInfo(<span class="hljs-string">&quot;linux&quot;</span>, <span class="hljs-string">&quot;amd64&quot;</span>)
    entryPoint := findEntryPoint(notes, bi.Arch.PtrSize()) <span class="hljs-comment">// saved in dlv header in PT_NOTE segment</span>

    p := &amp;process{
        mem:         memory,
        Threads:     <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]*thread{},
        entryPoint:  entryPoint,
        bi:          bi,
        breakpoints: proc.NewBreakpointMap(),
    }

    <span class="hljs-keyword">if</span> platformIndependentDelveCore {
        currentThread, err := threadsFromDelveNotes(p, notes)
        <span class="hljs-keyword">return</span> p, currentThread, err
    }

    currentThread := linuxThreadsFromNotes(p, notes, machineType)
    <span class="hljs-keyword">return</span> p, currentThread, <span class="hljs-literal">nil</span>
}
</code></pre>
<p>The two most crucial steps here are establishing the memory scene and process state scene.</p>
<p>We haven&apos;t introduced note types in detail before:</p>
<pre><code class="lang-go"><span class="hljs-comment">// Note is a note from the PT_NOTE prog.</span>
<span class="hljs-comment">// Relevant types:</span>
<span class="hljs-comment">// - NT_FILE: File mapping information, e.g. program text mappings. Desc is a LinuxNTFile.</span>
<span class="hljs-comment">// - NT_PRPSINFO: Information about a process, including PID and signal. Desc is a LinuxPrPsInfo.</span>
<span class="hljs-comment">// - NT_PRSTATUS: Information about a thread, including base registers, state, etc. Desc is a LinuxPrStatus.</span>
<span class="hljs-comment">// - NT_FPREGSET (Not implemented): x87 floating point registers.</span>
<span class="hljs-comment">// - NT_X86_XSTATE: Other registers, including AVX and such.</span>
<span class="hljs-keyword">type</span> note <span class="hljs-keyword">struct</span> {
    Type elf.NType
    Name <span class="hljs-keyword">string</span>
    Desc <span class="hljs-keyword">interface</span>{} <span class="hljs-comment">// Decoded Desc from the</span>
}
</code></pre>
<p>OK, let&apos;s look at buildMemory. This function mainly processes PT_NOTE and PT_LOAD types in two steps:
1) For program headers of type PT_NOTE, notes with type note.Type=_NT_FILE represent non-anonymous VMA region mappings of some files;
   When Linux generates core files, it includes these; tinydbg dumps all memory regions as PT_LOAD.
2) For program headers of type PT_LOAD, it mainly reads some data from the executable program;</p>
<pre><code class="lang-go"><span class="hljs-keyword">func</span> buildMemory(core, exeELF *elf.File, exe io.ReaderAt, notes []*note) proc.MemoryReader {
    memory := &amp;SplicedMemory{}

    <span class="hljs-comment">// tinydbg doesn&apos;t generate note.Type=NT_FILE notes information,</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// - For Go programs, if the core file is generated by the kernel, it will include this, see linux `fill_files_notes`</span>
    <span class="hljs-comment">// - For tinydbg&gt; debug my.core, this information is not generated</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// Here we assume all file mappings come from exe, which is obviously incorrect, as shared libraries and other external files are not included</span>
    <span class="hljs-comment">// - 1) For read-only files, they usually aren&apos;t stored in the core file (to save space), so we need to read from external files</span>
    <span class="hljs-comment">//      The support here is insufficient!!!</span>
    <span class="hljs-comment">//      Because the readNote function only reads VMA.start/end/offsetByPage, but doesn&apos;t read the actual mapped filenames!</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// - 2) For read-write files, the kernel usually dumps this data during core dump, so we should prioritize core file data,</span>
    <span class="hljs-comment">//      to avoid blindly reading external file data and causing overwrites</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// For now, assume all file mappings are to the exe.</span>
    <span class="hljs-keyword">for</span> _, note := <span class="hljs-keyword">range</span> notes {

        <span class="hljs-keyword">if</span> note.Type == _NT_FILE {
            fileNote := note.Desc.(*linuxNTFile)
            <span class="hljs-keyword">for</span> _, entry := <span class="hljs-keyword">range</span> fileNote.entries {
                r := &amp;offsetReaderAt{
                    <span class="hljs-comment">// why? Because it assumes Go is mostly statically compiled, doesn&apos;t use shared libraries, and doesn&apos;t involve mmap files,</span>
                    <span class="hljs-comment">// so this is the basic case when the kernel generates coredump. This implementation can be optimized</span>
                    reader: exe, 
                    offset: entry.Start - (entry.FileOfs * fileNote.PageSize),
                }
                memory.Add(r, entry.Start, entry.End-entry.Start)
            }
        }
    }

    <span class="hljs-comment">// Load memory segments from exe and then from the core file,</span>
    <span class="hljs-comment">// allowing the corefile to overwrite previously loaded segments</span>
    <span class="hljs-keyword">for</span> _, elfFile := <span class="hljs-keyword">range</span> []*elf.File{exeELF, core} {
        <span class="hljs-keyword">if</span> elfFile == <span class="hljs-literal">nil</span> {
            <span class="hljs-keyword">continue</span>
        }
        <span class="hljs-keyword">for</span> _, prog := <span class="hljs-keyword">range</span> elfFile.Progs {
            <span class="hljs-keyword">if</span> prog.Type == elf.PT_LOAD {
                <span class="hljs-keyword">if</span> prog.Filesz == <span class="hljs-number">0</span> {
                    <span class="hljs-keyword">continue</span>
                }
                r := &amp;offsetReaderAt{
                    reader: prog.ReaderAt,
                    offset: prog.Vaddr,
                }
                memory.Add(r, prog.Vaddr, prog.Filesz)
            }
        }
    }
    <span class="hljs-keyword">return</span> memory
}
</code></pre>
<p>Note that for notes of type NT_FILE, these are generated when the kernel creates core files. In tinydbg&apos;s dump-generated core files, everything is dumped as PT_LOAD type, dumping all mapped memory as PT_LOAD segments for simplicity. When the kernel creates them, it dumps non-anonymous mapped VMA file information as PT_NOTE, with note.Type=NT_FILE. Although the above code assumes all mapped files come from the executable is not entirely correct, even so, it won&apos;t affect debugging accuracy, because these notes only record the mapping relationship between VMAs and files, not the actual data - the data still needs to be looked at in the PT_LOAD type sections. Actually, the already read file contents are already in the process address space, and when the kernel generates core files, it records the location of mapped data in the core file, so we can know the contents of already mapped files... So although <code>offsetReaderAt{reader: exe, ...}</code> looks incorrect, if this data has already been dumped through PT_LOAD segments, there&apos;s no problem, as the data can be read.</p>
<p>However, some articles mention that for read-only PT_LOAD segments where FileSZ==0 &amp;&amp; MemSZ != 0, and they are Non-Anonymous VMA regions, to get the data we need to read from external storage based on the filenames in the PT_NOTE table&apos;s mapped files. But since readNote processing explicitly ignores these filenames, I believe tinydbg debugging might encounter issues in certain scenarios. However, this isn&apos;t a problem we want to solve comprehensively in this section, just something to understand.</p>
<pre><code class="lang-go"><span class="hljs-comment">// readNote reads a single note from r, decoding the descriptor if possible.</span>
<span class="hljs-keyword">func</span> readNote(r io.ReadSeeker, machineType elf.Machine) (*note, error) {
    <span class="hljs-comment">// Notes are laid out as described in the SysV ABI:</span>
    <span class="hljs-comment">// https://www.sco.com/developers/gabi/latest/ch5.pheader.html#note_section</span>
    note := &amp;note{}
    hdr := &amp;elfNotesHdr{}

    err := binary.Read(r, binary.LittleEndian, hdr)
    note.Type = elf.NType(hdr.Type)

    name := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">byte</span>, hdr.Namesz)
    note.Name = <span class="hljs-keyword">string</span>(name)
    desc := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">byte</span>, hdr.Descsz)

    descReader := bytes.NewReader(desc)
    <span class="hljs-keyword">switch</span> note.Type {
    <span class="hljs-keyword">case</span> elf.NT_PRSTATUS:
        note.Desc = &amp;linuxPrStatusAMD64{}
    <span class="hljs-keyword">case</span> elf.NT_PRPSINFO:
        note.Desc = &amp;linuxPrPsInfo{}
        binary.Read(descReader, binary.LittleEndian, note.Desc)
    <span class="hljs-keyword">case</span> _NT_FILE:
        <span class="hljs-comment">// No good documentation reference, but the structure is</span>
        <span class="hljs-comment">// simply a header, including entry count, followed by that</span>
        <span class="hljs-comment">// many entries, and then the file name of each entry,</span>
        <span class="hljs-comment">// null-delimited. Not reading the names here.</span>
        data := &amp;linuxNTFile{}
        binary.Read(descReader, binary.LittleEndian, &amp;data.linuxNTFileHdr)
        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">int</span>(data.Count); i++ {
            entry := &amp;linuxNTFileEntry{}
            binary.Read(descReader, binary.LittleEndian, entry)
            data.entries = <span class="hljs-built_in">append</span>(data.entries, entry)
        }
        note.Desc = data
    <span class="hljs-keyword">case</span> _NT_X86_XSTATE:
        <span class="hljs-keyword">if</span> machineType == _EM_X86_64 {
            <span class="hljs-keyword">var</span> fpregs amd64util.AMD64Xstate
            amd64util.AMD64XstateRead(desc, <span class="hljs-literal">true</span>, &amp;fpregs, <span class="hljs-number">0</span>)
            note.Desc = &amp;fpregs
        }
    <span class="hljs-keyword">case</span> _NT_AUXV, elfwriter.DelveHeaderNoteType, elfwriter.DelveThreadNodeType:
        note.Desc = desc
    }
    skipPadding(r, <span class="hljs-number">4</span>)
    <span class="hljs-keyword">return</span> note, <span class="hljs-literal">nil</span>
}
</code></pre>
<p>Also, referring to the implementation of <code>fill_files_note(struct memelfnote *note)</code> in the kernel source code, this function shows the data format of NT_FILE notes. We can see that long start, long end, long file_ofs are positions in the VMA, not in the mapped files. So as mentioned earlier, as long as the mapped files&apos; contents, besides the mapping relationships in PT_NOTE, are dumped to the core file&apos;s PT_LOAD segments, when we buildMemory from the core file and establish SplicedMemory, which contains all VMA regions of the process at coredump time, we can actually read from this SplicedMemory when reading memory later, and we can read it, without needing to read external files. But the premise is that it was dumped (FileSZ != 0).</p>
<p>Actually, although the VMA corresponding to a mapped file might be read-only during process execution, it might not be on the filesystem, and could still be modified, so reading from external files during debugging would be problematic. So I think, for debugging convenience, we should still dump this data into the core file, even though the core file will be larger. But we probably don&apos;t care that much about disk usage.</p>
<blockquote>
<p>ps: The complete address space of the process, all these VMAs, won&apos;t be dumped to the core file. But some VMAs don&apos;t have physical memory mappings established, and when recording these in the core file, only necessary information is recorded, with no actual data and no zero values written, but there are indeed some holes left in the file. In this case, <code>ls -h</code> will show a larger file size, but <code>du -hs</code> will show a smaller size. When I was doing game server development, I observed that the battle server process core file size showed as high as 80GB with <code>ls</code>, but actually only about 800MB+ with <code>du</code>.</p>
</blockquote>
<pre><code class="lang-c"><span class="hljs-comment">/*
 * Format of NT_FILE note:
 *
 * long count     -- how many files are mapped
 * long page_size -- units for file_ofs
 * array of [COUNT] elements of
 *   long start
 *   long end
 *   long file_ofs
 * followed by COUNT filenames in ASCII: &quot;FILE1&quot; NUL &quot;FILE2&quot; NUL...
 */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fill_files_note</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> memelfnote *note)</span>
</span>{
    <span class="hljs-keyword">struct</span> vm_area_struct *vma;
    <span class="hljs-keyword">unsigned</span> count, size, names_ofs, remaining, n;
    <span class="hljs-keyword">user_long_t</span> *data;
    <span class="hljs-keyword">user_long_t</span> *start_end_ofs;
    <span class="hljs-keyword">char</span> *name_base, *name_curpos;

    <span class="hljs-comment">/* *Estimated* file count and total data size needed */</span>
    count = current-&gt;mm-&gt;map_count;
    size = count * <span class="hljs-number">64</span>;

    names_ofs = (<span class="hljs-number">2</span> + <span class="hljs-number">3</span> * count) * <span class="hljs-keyword">sizeof</span>(data[<span class="hljs-number">0</span>]);
 alloc:
    size = round_up(size, PAGE_SIZE);
    data = kvmalloc(size, GFP_KERNEL);

    start_end_ofs = data + <span class="hljs-number">2</span>;
    name_base = name_curpos = ((<span class="hljs-keyword">char</span> *)data) + names_ofs;
    remaining = size - names_ofs;
    count = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (vma = current-&gt;mm-&gt;mmap; vma != <span class="hljs-literal">NULL</span>; vma = vma-&gt;vm_next) {
        <span class="hljs-keyword">struct</span> file *file;
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *filename;

        file = vma-&gt;vm_file;
        filename = file_path(file, name_curpos, remaining);

        <span class="hljs-comment">/* file_path() fills at the end, move name down */</span>
        <span class="hljs-comment">/* n = strlen(filename) + 1: */</span>
        n = (name_curpos + remaining) - filename;
        remaining = filename - name_curpos;
        memmove(name_curpos, filename, n);
        name_curpos += n;

        *start_end_ofs++ = vma-&gt;vm_start;
        *start_end_ofs++ = vma-&gt;vm_end;
        *start_end_ofs++ = vma-&gt;vm_pgoff;
        count++;
    }

    <span class="hljs-comment">/* Now we know exact count of files, can store it */</span>
    data[<span class="hljs-number">0</span>] = count;
    data[<span class="hljs-number">1</span>] = PAGE_SIZE;
    ...

    size = name_curpos - (<span class="hljs-keyword">char</span> *)data;
    fill_note(note, <span class="hljs-string">&quot;CORE&quot;</span>, NT_FILE, size, data);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<h4 id="subsequent-memory-reading-operations">Subsequent Memory Reading Operations</h4>
<p>Note that when tracking process memory mappings during core file buildMemory:</p>
<pre><code class="lang-go"><span class="hljs-keyword">type</span> SplicedMemory <span class="hljs-keyword">struct</span> {
    readers []readerEntry
}

<span class="hljs-keyword">func</span> buildMemory(core, exeELF *elf.File, exe io.ReaderAt, notes []*note) proc.MemoryReader {
    memory := &amp;SplicedMemory{}

    <span class="hljs-comment">// For now, assume all file mappings are to the exe.</span>
    <span class="hljs-keyword">for</span> _, note := <span class="hljs-keyword">range</span> notes {
        <span class="hljs-keyword">if</span> note.Type == _NT_FILE {
            fileNote := note.Desc.(*linuxNTFile)
            <span class="hljs-keyword">for</span> _, entry := <span class="hljs-keyword">range</span> fileNote.entries {
                r := &amp;offsetReaderAt{
                    reader: exe,
                    offset: entry.Start - (entry.FileOfs * fileNote.PageSize),
                }
                memory.Add(r, entry.Start, entry.End-entry.Start)
            }
        }
    }

    <span class="hljs-comment">// Load memory segments from exe and then from the core file,</span>
    <span class="hljs-comment">// allowing the corefile to overwrite previously loaded segments</span>
    <span class="hljs-keyword">for</span> _, elfFile := <span class="hljs-keyword">range</span> []*elf.File{exeELF, core} {
        <span class="hljs-keyword">if</span> elfFile == <span class="hljs-literal">nil</span> {
            <span class="hljs-keyword">continue</span>
        }
        <span class="hljs-keyword">for</span> _, prog := <span class="hljs-keyword">range</span> elfFile.Progs {
            <span class="hljs-keyword">if</span> prog.Type == elf.PT_LOAD {
                <span class="hljs-keyword">if</span> prog.Filesz == <span class="hljs-number">0</span> {
                    <span class="hljs-keyword">continue</span>
                }
                r := &amp;offsetReaderAt{
                    reader: prog.ReaderAt,
                    offset: prog.Vaddr,
                }
                memory.Add(r, prog.Vaddr, prog.Filesz)
            }
        }
    }
    <span class="hljs-keyword">return</span> memory
}
</code></pre>
<p>We focus on the readers construction in the lower part:</p>
<pre><code>        for _, prog := range elfFile.Progs {
            if prog.Type == elf.PT_LOAD {
                if prog.Filesz == 0 {
                    continue
                }
                r := &amp;offsetReaderAt{
                    reader: prog.ReaderAt,
                    offset: prog.Vaddr,
                }
                memory.Add(r, prog.Vaddr, prog.Filesz)
            }
        }
</code></pre><p>We only process parts that have mappings and FileSZ != 0. If FileSZ == 0, we simply skip processing (recall that we didn&apos;t record filenames in readNote either, so we can&apos;t read them, and even if we could read them, since these files themselves might have changed, it wouldn&apos;t be useful to us). Then we put these memory regions with data into our SplicedMemory, with each VMA corresponding to a reader like this:</p>
<pre><code class="lang-go">                r := &amp;offsetReaderAt{
                    reader: prog.ReaderAt,
                    offset: prog.Vaddr,
                }
</code></pre>
<p>Later, when we need to read memory, instead of reading through ptrace(PTRACE_PEEKTEXT/PEEKDATA, ...) like when debugging a process, we read directly from the readers in SplicedMemory:</p>
<ol>
<li>First determine which VMAs&apos; corresponding readers the data is in based on the starting address and data size to be read;</li>
<li>Then read from these readers;</li>
<li>The starting address for reading from each reader is already recorded, and the starting address is actually the VirtSize of each PT_LOAD type in the core file.
ps: In part 1 we mentioned that in executable programs, VirtSize represents the loading address of PT_LOAD type in the process address space, but in core files, it represents the offset in the core file.</li>
</ol>
<h4 id="subsequent-register-reading-operations">Subsequent Register Reading Operations</h4>
<p>This is naturally even simpler. This information is recorded in the PT_NOTE corresponding segment, and when we read it, we&apos;ve already parsed it and placed it in appropriate data structures, so it&apos;s not a problem.</p>
<h4 id="subsequent-initialization-and-debugging">Subsequent Initialization and Debugging</h4>
<p>Afterward, the debugger continues to initialize the debug session and network communication parts, and can then examine the problem scene based on the core file and try to locate issues.</p>
<h3 id="execution-testing">Execution Testing</h3>
<p>Even after opening a core file, it&apos;s just reading a snapshot. Although it reconstructs the problem scene, it doesn&apos;t reconstruct the process, so debug commands involving execution in the debug session cannot be executed. Core file debugging typically uses bt to observe the stack, frame to select stack frames, and locals/args to view function parameters and local variable information.</p>
<p>Test examples omitted.</p>
<h3 id="summary">Summary</h3>
<p>This article has introduced how tinydbg generates and loads core files, including:</p>
<ol>
<li>The basic concepts and structure of core files</li>
<li>How core files are generated by the Linux kernel and custom tools</li>
<li>The implementation details of tinydbg&apos;s core file generation and loading</li>
<li>How memory and register information is handled during core file operations</li>
<li>The limitations and considerations in core file debugging</li>
</ol>
<p>Through this implementation, tinydbg provides a powerful tool for post-mortem debugging, allowing developers to analyze program crashes and issues after they occur.</p>
<p>The only shortcoming is that for some non-anonymous mapped file VMAs with FileSZ==0, this data might not be written out by the kernel, and these mapped files might be modified afterward. Even if we read them back, they won&apos;t match the problem scene at that time. This is a real issue.</p>
<p>tinydbg doesn&apos;t handle reading these mapped files, but rather selectively ignores them. Because even if it supported reading them, it couldn&apos;t properly handle these real existing problems.
tinydbg has done quite well as is, see discussion here: <a href="https://github.com/go-delve/delve/discussions/4031" target="_blank">https://github.com/go-delve/delve/discussions/4031</a>.</p>
<h4 id="subsequent-memory-reading-operations">Subsequent Memory Reading Operations</h4>
<p>Note that when tracking process memory mappings during core file buildMemory:</p>
<pre><code class="lang-go"><span class="hljs-keyword">type</span> SplicedMemory <span class="hljs-keyword">struct</span> {
    readers []readerEntry
}

<span class="hljs-keyword">func</span> buildMemory(core, exeELF *elf.File, exe io.ReaderAt, notes []*note) proc.MemoryReader {
    memory := &amp;SplicedMemory{}

    <span class="hljs-comment">// For now, assume all file mappings are to the exe.</span>
    <span class="hljs-keyword">for</span> _, note := <span class="hljs-keyword">range</span> notes {
        <span class="hljs-keyword">if</span> note.Type == _NT_FILE {
            fileNote := note.Desc.(*linuxNTFile)
            <span class="hljs-keyword">for</span> _, entry := <span class="hljs-keyword">range</span> fileNote.entries {
                r := &amp;offsetReaderAt{
                    reader: exe,
                    offset: entry.Start - (entry.FileOfs * fileNote.PageSize),
                }
                memory.Add(r, entry.Start, entry.End-entry.Start)
            }
        }
    }

    <span class="hljs-comment">// Load memory segments from exe and then from the core file,</span>
    <span class="hljs-comment">// allowing the corefile to overwrite previously loaded segments</span>
    <span class="hljs-keyword">for</span> _, elfFile := <span class="hljs-keyword">range</span> []*elf.File{exeELF, core} {
        <span class="hljs-keyword">if</span> elfFile == <span class="hljs-literal">nil</span> {
            <span class="hljs-keyword">continue</span>
        }
        <span class="hljs-keyword">for</span> _, prog := <span class="hljs-keyword">range</span> elfFile.Progs {
            <span class="hljs-keyword">if</span> prog.Type == elf.PT_LOAD {
                <span class="hljs-keyword">if</span> prog.Filesz == <span class="hljs-number">0</span> {
                    <span class="hljs-keyword">continue</span>
                }
                r := &amp;offsetReaderAt{
                    reader: prog.ReaderAt,
                    offset: prog.Vaddr,
                }
                memory.Add(r, prog.Vaddr, prog.Filesz)
            }
        }
    }
    <span class="hljs-keyword">return</span> memory
}
</code></pre>
<p>We focus on the readers construction in the lower part:</p>
<pre><code>        for _, prog := range elfFile.Progs {
            if prog.Type == elf.PT_LOAD {
                if prog.Filesz == 0 {
                    continue
                }
                r := &amp;offsetReaderAt{
                    reader: prog.ReaderAt,
                    offset: prog.Vaddr,
                }
                memory.Add(r, prog.Vaddr, prog.Filesz)
            }
        }
</code></pre><p>We only process parts that have mappings and FileSZ != 0. If FileSZ == 0, we simply skip processing (recall that we didn&apos;t record filenames in readNote either, so we can&apos;t read them, and even if we could read them, since these files themselves might have changed, it wouldn&apos;t be useful to us). Then we put these memory regions with data into our SplicedMemory, with each VMA corresponding to a reader like this:</p>
<pre><code class="lang-go">                r := &amp;offsetReaderAt{
                    reader: prog.ReaderAt,
                    offset: prog.Vaddr,
                }
</code></pre>
<p>Later, when we need to read memory, instead of reading through ptrace(PTRACE_PEEKTEXT/PEEKDATA, ...) like when debugging a process, we read directly from the readers in SplicedMemory:</p>
<ol>
<li>First determine which VMAs&apos; corresponding readers the data is in based on the starting address and data size to be read;</li>
<li>Then read from these readers;</li>
<li>The starting address for reading from each reader is already recorded, and the starting address is actually the VirtSize of each PT_LOAD type in the core file.
ps: In part 1 we mentioned that in executable programs, VirtSize represents the loading address of PT_LOAD type in the process address space, but in core files, it represents the offset in the core file.</li>
</ol>
<h4 id="subsequent-register-reading-operations">Subsequent Register Reading Operations</h4>
<p>This is naturally even simpler. This information is recorded in the PT_NOTE corresponding segment, and when we read it, we&apos;ve already parsed it and placed it in appropriate data structures, so it&apos;s not a problem.</p>
<h4 id="subsequent-initialization-and-debugging">Subsequent Initialization and Debugging</h4>
<p>Afterward, the debugger continues to initialize the debug session and network communication parts, and can then examine the problem scene based on the core file and try to locate issues.</p>
<h3 id="execution-testing">Execution Testing</h3>
<p>Even after opening a core file, it&apos;s just reading a snapshot. Although it reconstructs the problem scene, it doesn&apos;t reconstruct the process, so debug commands involving execution in the debug session cannot be executed. Core file debugging typically uses bt to observe the stack, frame to select stack frames, and locals/args to view function parameters and local variable information.</p>
<p>Test examples omitted.</p>
<h3 id="summary">Summary</h3>
<p>This article has introduced how tinydbg generates and loads core files, including:</p>
<ol>
<li>The basic concepts and structure of core files</li>
<li>How core files are generated by the Linux kernel and custom tools</li>
<li>The implementation details of tinydbg&apos;s core file generation and loading</li>
<li>How memory and register information is handled during core file operations</li>
<li>The limitations and considerations in core file debugging</li>
</ol>
<p>Through this implementation, tinydbg provides a powerful tool for post-mortem debugging, allowing developers to analyze program crashes and issues after they occur.</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="15-tinydbg_core1.html" class="navigation navigation-prev " aria-label="Previous page: 9.2.15 tinydbg core - part1">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="16-tinydbg_connect.html" class="navigation navigation-next " aria-label="Next page: 9.2.16 tinydbg connect">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"9.2.15 tinydbg core - part2","level":"1.9.2.8","depth":3,"next":{"title":"9.2.16 tinydbg connect","level":"1.9.2.9","depth":3,"path":"9-develop-sym-debugger/2-æ ¸å¿è°è¯é»è¾/16-tinydbg_connect.md","ref":"9-develop-sym-debugger/2-æ ¸å¿è°è¯é»è¾/16-tinydbg_connect.md","articles":[]},"previous":{"title":"9.2.15 tinydbg core - part1","level":"1.9.2.7","depth":3,"path":"9-develop-sym-debugger/2-æ ¸å¿è°è¯é»è¾/15-tinydbg_core1.md","ref":"9-develop-sym-debugger/2-æ ¸å¿è°è¯é»è¾/15-tinydbg_core1.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":["md-toc"],"pluginsConfig":{"intopic-toc":{"selector":".markdown-section h1, .markdown-section h2, .markdown-section h3, .markdown-section h4, .markdown-section h5, .markdown-section h6","visible":true,"label":{"en":"In This Article","zh":"æ¬æç®å½"}},"md-toc":{"label":"In this article","selector":".markdown-section h2","visible":true},"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"9-develop-sym-debugger/2-æ ¸å¿è°è¯é»è¾/15-tinydbg_core2.md","mtime":"2025-06-15T12:48:25.507Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2025-06-15T18:01:33.391Z"},"basePath":"../..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../../gitbook/gitbook.js"></script>
    <script src="../../gitbook/theme.js"></script>
    
        
        <script src="../../gitbook/gitbook-plugin-md-toc/anchor.min.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-md-toc/gumshoe.min.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-md-toc/plugin.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

